<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PA &amp; CODING</title>
  
  <subtitle>求仁得仁</subtitle>
  <link href="https://jxch.github.io/atom.xml" rel="self"/>
  
  <link href="https://jxch.github.io/"/>
  <updated>2024-09-09T02:44:46.657Z</updated>
  <id>https://jxch.github.io/</id>
  
  <author>
    <name>钱不寒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper-ZAB</title>
    <link href="https://jxch.github.io/2024/09/09/architect/zookeeper/zookeeper-zab/"/>
    <id>https://jxch.github.io/2024/09/09/architect/zookeeper/zookeeper-zab/</id>
    <published>2024-09-09T02:41:00.000Z</published>
    <updated>2024-09-09T02:44:46.657Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ZAB</li><li>消息广播</li><li>崩溃恢复</li><li>数据同步</li></ul><hr><h2 id="ZAB">ZAB</h2><ul><li>整个Zookeeper就是一个多节点分布式一致性算法的实现，底层采用的实现协议是ZAB</li><li>ZAB&nbsp;协议全称：Zookeeper&nbsp;Atomic&nbsp;Broadcast（Zookeeper&nbsp;原子广播协议）<ul><li>ZAB是Paxos算法的一种简化实现</li></ul></li><li>ZAB&nbsp;协议是为分布式协调服务&nbsp;Zookeeper&nbsp;专门设计的一种支持&nbsp;崩溃恢复&nbsp;和&nbsp;原子广播&nbsp;的协议<ul><li>当&nbsp;Leader&nbsp;服务可以正常使用，就进入消息广播模式</li><li>当&nbsp;Leader&nbsp;不可用时，则进入崩溃恢复模式</li></ul></li><li>基于该协议，Zookeeper&nbsp;实现了一种&nbsp;主备模式&nbsp;的系统架构来保持集群中各个副本之间数据一致性</li><li><img src="/static/IT/Zookeeper/Zookeeper-ZAB-1.png" alt=""><ul><li>所有客户端写入数据都是写入到Leader节点</li><li>然后，由&nbsp;Leader&nbsp;复制到Follower节点中，从而保证数据一致性</li><li>复制过程类似两阶段提交 (2PC)<ul><li>ZAB&nbsp;只需要&nbsp;Follower(含leader自己的ack)&nbsp;有一半以上返回&nbsp;Ack&nbsp;信息就可以执行提交<ul><li>大大减小了同步阻塞；也提高了可用性</li></ul></li></ul></li></ul></li></ul><h2 id="消息广播">消息广播</h2><ul><li>ZAB&nbsp;协议的消息广播过程使用的是一个原子广播协议，类似一个&nbsp;两阶段提交过程</li><li>对于客户端发送的写请求，全部由&nbsp;Leader&nbsp;接收，Leader&nbsp;将请求封装成一个事务&nbsp;Proposal，将其发送给所有&nbsp;Follwer</li><li>然后，根据所有&nbsp;Follwer&nbsp;的反馈，如果超过半数 (含leader自己) 成功响应，则执行&nbsp;commit&nbsp;操作</li><li><img src="/static/IT/Zookeeper/Zookeeper-ZAB-2.png" alt=""><ul><li>Leader&nbsp;在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一&nbsp;ID，称为事务ID（ZXID），ZAB&nbsp;协议需要保证事务的顺序，因此必须将每一个事务按照&nbsp;ZXID&nbsp;进行先后排序然后处理，主要通过消息队列实现</li><li>在&nbsp;Leader&nbsp;和&nbsp;Follwer&nbsp;之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞</li><li>zookeeper集群中为保证所有进程能够有序的顺序执行，只能是&nbsp;Leader&nbsp;服务器接受写请求，即使是&nbsp;Follower&nbsp;服务器接受到客户端的写请求，也会转发到&nbsp;Leader&nbsp;服务器进行处理，Follower只能处理读请求</li><li>ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃</li></ul></li></ul><h2 id="崩溃恢复">崩溃恢复</h2><ul><li>当&nbsp;Leader&nbsp;崩溃，即进入崩溃恢复模式（崩溃即：Leader&nbsp;失去与过半&nbsp;Follwer&nbsp;的联系）<ul><li>Leader&nbsp;在复制数据给所有&nbsp;Follwer&nbsp;之后，还没来得及收到Follower的ack返回就崩溃</li><li>Leader&nbsp;在收到&nbsp;ack&nbsp;并提交了自己，同时发送了部分&nbsp;commit&nbsp;出去之后崩溃</li></ul></li><li>针对这些问题，ZAB&nbsp;定义了&nbsp;2&nbsp;个原则<ul><li>ZAB&nbsp;协议确保丢弃那些只在&nbsp;Leader&nbsp;提出/复制，但没有提交的事务</li><li>ZAB&nbsp;协议确保那些已经在&nbsp;Leader&nbsp;提交的事务最终会被所有服务器提交</li></ul></li><li>所以，ZAB&nbsp;设计了下面这样一个选举算法：能够确保提交已经被&nbsp;Leader&nbsp;提交的事务，同时丢弃已经被跳过的事务<ul><li>让&nbsp;Leader&nbsp;选举算法能够保证新选举出来的&nbsp;Leader&nbsp;服务器拥有集群中所有机器&nbsp;ZXID&nbsp;最大的事务<ul><li>可以省去&nbsp;Leader&nbsp;服务器检查事务的提交和丢弃工作的这一步操作</li></ul></li></ul></li></ul><h2 id="数据同步">数据同步</h2><ul><li>当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader&nbsp;服务器首先确认事务是否都已经被过半的&nbsp;Follwer&nbsp;提交了，即是否完成了数据同步。目的是为了保持数据一致</li><li>当&nbsp;Follwer&nbsp;服务器成功同步之后，Leader&nbsp;会将这些服务器加入到可用服务器列表中</li><li>实际上，Leader&nbsp;服务器处理或丢弃事务都是依赖着&nbsp;ZXID&nbsp;的<ul><li><img src="/static/IT/Zookeeper/Zookeeper-ZAB-3.png" alt=""></li><li>在&nbsp;ZAB&nbsp;协议的事务编号&nbsp;ZXID&nbsp;设计中，ZXID&nbsp;是一个&nbsp;64&nbsp;位的数字<ul><li>其中低&nbsp;32&nbsp;位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader&nbsp;都会产生一个新的事务&nbsp;Proposal&nbsp;并对该计数器进行&nbsp;+&nbsp;1&nbsp;操作</li><li>而高&nbsp;32&nbsp;位则代表了&nbsp;Leader&nbsp;服务器上取出本地日志中最大事务&nbsp;Proposal&nbsp;的&nbsp;ZXID，并从该&nbsp;ZXID&nbsp;中解析出对应的&nbsp;epoch&nbsp;值 (leader选举周期)，当一轮新的选举结束后，会对这个值加一，并且事务id又从0开始自增</li></ul></li><li>高&nbsp;32&nbsp;位代表了每代&nbsp;Leader&nbsp;的唯一性，低&nbsp;32&nbsp;代表了每代&nbsp;Leader&nbsp;中事务的唯一性<ul><li>同时，也能让&nbsp;Follwer&nbsp;通过高&nbsp;32&nbsp;位识别不同的&nbsp;Leader。简化了数据恢复流程</li></ul></li></ul></li><li>当&nbsp;Follower&nbsp;连接上&nbsp;Leader&nbsp;之后，Leader&nbsp;服务器会根据自己服务器上最后被提交的&nbsp;ZXID&nbsp;和&nbsp;Follower&nbsp;上的&nbsp;ZXID&nbsp;进行比对，比对结果要么回滚，要么和&nbsp;Leader&nbsp;同步</li></ul><hr><p><img src="/static/IT/Zookeeper/Zookeeper-ZAB-4.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;ZAB&lt;/li&gt;
&lt;li&gt;消息广播&lt;/li&gt;
&lt;li&gt;崩溃恢复&lt;/li&gt;
&lt;li&gt;数据同步&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;ZAB&quot;&gt;ZAB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;整个Zookeeper就是一个多节点分布式一致性算法的实现，底层采用的实现协</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Zookeeper" scheme="https://jxch.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-整体架构</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-zheng-ti-jia-gou/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-zheng-ti-jia-gou/</id>
    <published>2024-09-09T02:33:00.000Z</published>
    <updated>2024-09-09T02:37:37.979Z</updated>
    
    <content type="html"><![CDATA[<ul><li>NameServer的结构</li><li>Broker的结构</li><li>Netty服务注册框架</li><li>RocketMQ的同步结果推送与异步结果推送</li><li>Broker心跳注册过程</li><li>Producer发送消息过程</li><li>Consumer拉取消息过程</li><li>文件存储</li><li>延迟消息</li><li>长轮询机制</li></ul><hr><h2 id="NameServer的结构">NameServer的结构</h2><ul><li>NameServer的核心作用<ul><li>一是维护Broker的服务地址并进行及时的更新</li><li>二是给Producer和Consumer提供服务获取Broker列表</li></ul></li><li>NameServer的启动入口为NamesrvStartup类的main方法</li><li>整个NameServer的核心就是一个NamesrvController对象</li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-1.png" alt=""></p><hr><h2 id="Broker的结构">Broker的结构</h2><ul><li>Broker是整个RocketMQ的业务核心，所有消息存储、转发这些最为重要的业务都是在Broker中进行处理的</li><li>Broker启动的入口在BrokerStartup这个类的main方法</li><li>重点也是围绕一个BrokerController对象</li><li>在BrokerStartup.createBrokerController方法中可以看到Broker的几个核心配置<ul><li>BrokerConfig</li><li>NettyServerConfig  ：Netty服务端占用了10911端口。同样也可以在配置文件中覆盖</li><li>NettyClientConfig</li><li>MessageStoreConfig</li></ul></li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-2.png" alt=""></p><hr><h2 id="Netty服务注册框架">Netty服务注册框架</h2><ul><li>RocketMQ使用Netty框架提供了一套基于服务码的服务注册机制，让各种不同的组件都可以按照自己的需求，注册自己的服务方法</li><li>Netty的所有远程通信功能都由remoting模块实现。RemotingServer模块里包含了RPC的服务端RemotingServer以及客户端RemotingClient</li><li>RocketMQ基于Netty保持客户端与服务端的长连接Channel</li><li>所有的请求都封装成RemotingCommand对象。而每个处理消息的服务逻辑，会封装成一个NettyRequestProcessor对象</li><li>服务端和客户端都维护了一个processorTable，这是个HashMap，key是服务码requestCode，value是对应的运行单元<ul><li>Pair&lt;NettyRequestProcessor, ExecutorService&gt;  类型，包含了处理逻辑Prcessor和执行线程池ExecutorService</li></ul></li><li>服务端的注册BrokerController.registerProcessor() ，客户端的服务注册见MQClientAPIImpl。NameServer则会注册一个大的DefaultRequestProcessor，统一处理所有的服务</li><li>服务注册流程：</li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-3.png" alt=""></p><ul><li>NameServer会维护Broker的路由列表，并对路由列表进行实时更新</li><li>BrokerController.this.registerBrokerAll方法会发起向NameServer注册心跳。启动时会立即注册，同时也会启动一个线程池，以10秒延迟，默认30秒的间隔持续向NameServer发送心跳</li><li>BrokerController.this.registerBrokerAll这个方法就是注册心跳的入口</li><li>然后，在NameServer中也会启动一个定时任务，扫描不活动的Broker。具体观察NamesrvController.initialize方法</li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-4.png" alt=""></p><hr><h2 id="RocketMQ的同步结果推送与异步结果推送">RocketMQ的同步结果推送与异步结果推送</h2><ul><li>RocketMQ的RemotingServer服务端，会维护一个responseTable，这是一个线程同步的Map结构。 key为请求的ID，value是异步的消息结果 ConcurrentMap&lt;Integer  , ResponseFuture&gt;</li><li>处理同步请求(NettyRemotingAbstract#invokeSyncImpl)时，处理的结果会存入responseTable，通过ResponseFuture提供一定的服务端异步处理支持，提升服务端的吞吐量。 请求返回后，立即从responseTable中移除请求记录</li><li>处理异步请求(NettyRemotingAbstract#invokeAsyncImpl)时，处理的结果依然会存入responsTable，等待客户端后续再来请求结果。但是他保存的依然是一个ResponseFuture，也就是在客户端请求结果时再去获取真正的结果<ul><li>另外，在RemotingServer启动时，会启动一个定时的线程任务，不断扫描responseTable，将其中过期的response清除掉</li></ul></li></ul><hr><h2 id="Producer发送消息过程">Producer发送消息过程</h2><ul><li>Producer有两种<ul><li>普通发送者：DefaultMQProducer。只负责发送消息，发送完消息，就可以停止了<ul><li>DefaultMQProducer只需要构建一个Netty客户端，往Broker发送消息就行了</li><li>异步回调只是在Producer接收到Broker的响应后自行调整流程，不需要提供Netty服务</li></ul></li><li>事务消息发送者： TransactionMQProducer。支持事务消息机制。需要在事务消息过程中提供事务状态确认的服务，这就要求事务消息发送者虽然是一个客户端，但是也要完成整个事务消息的确认机制后才能退出<ul><li>TransactionMQProducer由于需要在事务消息机制中给Broker提供状态确认服务，所以在发送消息的同时，还需要保持连接，提供服务</li><li>TransactionMQProducer的启动过程中，会往RemotingClient中注册相应的Processor，这样RemotingServer和RemotingClient之间就可以通过channel进行双向的服务请求了</li></ul></li></ul></li><li>整个Producer的流程，大致分两个步骤<ul><li>start方法，进行一大堆的准备工作</li><li>各种各样的send方法，进行消息发送</li></ul></li><li>重点关注以下几个问题<ul><li>Producer的核心启动流程以及两种消息发送者的区别<ul><li>所有Producer的启动过程，最终都会调用DefaultMQProducerImpl#start方法<ul><li>在start方法中的通过一个mQClientFactory对象，启动生产者的一大堆重要服务</li></ul></li><li>所有客户端的启动流程是固定的，不同客户端的区别只是在于他们在启动前注册的一些信息不同<ul><li>生产者注册到producerTable，消费者注册到consumerTable，管理控制端注册到adminExtTable</li></ul></li></ul></li><li>Producer如何管理Borker路由信息<ul><li>Producer需要拉取Broker列表，然后跟Broker建立连接等等很多核心的流程，其实都是在发送消息时建立的。因为在启动时，还不知道要拉取哪个Topic的Broker列表呢</li><li>对NameServer的地址管理，则是散布在启动和发送的多个过程当中，并且NameServer地址可以通过一个Http服务来获取</li><li>Send方法中，首先需要获得Topic的路由信息。这会从本地缓存中获取，如果本地缓存中没有，就从NameServer中去申请 DefaultMQProducerImpl#tryToFindTopicPublishInfo 方法</li><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-5.png" alt=""></li></ul></li><li>Producer的负载均衡<ul><li>Producer在获取路由信息后，会选出一个MessageQueue去发送消息</li><li>这个选MessageQueue的方法就是一个索引自增然后取模的方式</li><li>然后根据MessageQueue再找所在的Broker，往Broker发送请求</li></ul></li><li>在发送Netty请求时，如何制定Broker<ul><li>实际上是指定的MessageQueue，而不是Topic。Topic只是用来找MessageQueue</li></ul></li></ul></li></ul><hr><h2 id="Consumer拉取消息过程">Consumer拉取消息过程</h2><ul><li>消费者也是有两种，推模式消费者（用的最多）和拉模式消费者</li><li>消费者组之间有集群模式和广播模式两种消费模式</li><li>消费者端的负载均衡的原理。即消费者是如何绑定消费队列的，哪些消费策略到底是如何落地的</li><li>在推模式的消费者中，MessageListenerConcurrently 和MessageListenerOrderly这两种消息监听器的处理逻辑到底有什么不同，为什么后者能保持消息顺序</li><li>DefaultMQPushConsumer.start作为入口。最终消费者的启动过程，跟生产者一样，也交由了mQClientFactory<ul><li>pullMessageService主要处理拉取消息服务；rebalanceService主要处理客户端的负载均衡</li></ul></li><li>客户端负载均衡策略<ul><li>在消费者示例的start方法中，启动RebalanceService，这个是客户端进行负载均衡策略的启动服务。他只负责根据负载均衡策略获取当前客户端分配到的MessageQueue</li><li>五种负载策略，可以由Consumer的allocateMessageQueueStrategy属性来选择<ul><li>这个属性可以在DefaultMQPushConsumer的构造方法当中指定。默认是AllocateMessageQueueAveragely策略</li><li>最常用的是AllocateMessageQueueAveragely平均分配和AllocateMessageQueueAveragelyByCircle平均轮询分配<ul><li>平均分配是把MessageQueue按组内的消费者个数平均分配</li><li>平均轮询分配就是把MessageQueue按组内的消费者一个一个轮询分配</li></ul></li></ul></li></ul></li><li>并发消费与顺序消费的过程<ul><li>消费的过程依然是在DefaultMQPushConsumerImpl的 consumeMessageService中</li><li>他有两个子类ConsumeMessageConcurrentlyService和ConsumeMessageOrderlyService</li><li>最主要的差别是ConsumeMessageOrderlyService会在消费前把队列锁起来，优先保证拉取同一个队列里的消息</li><li>消费过程的入口在DefaultMQPushConsumerImpl的pullMessage中定义的PullCallback中</li></ul></li><li>RocketMQ消息消费方式分别为集群模式、广播模式</li><li>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载<ul><li>根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配</li><li>分配原则为同一个消费者可以分配多个消息消费队列</li><li>同一个消息消费队列同一个时间只会分配给一个消费者</li></ul></li><li>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取<ul><li>默认每次拉取一批消息(可以由业务指定，默认是1)，提交给消费者消费线程后继续下一次消息拉取</li><li>如果消息消费过慢产生消息堆积会触发消息消费拉取流控</li></ul></li><li>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费<ul><li>消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中</li><li>集群模式消息消费进度存储在Broker（消息服务器）</li><li>广播模式消息消费进度存储在消费者端</li></ul></li><li>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别<ul><li>可通过在broker配置文件中设置messageDelayLevel</li></ul></li><li>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费<ul><li>与并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列</li><li>在Broker端会存储消息消费队列的锁占用情况</li></ul></li><li>拉模式核心服务类： PullMessageService<ul><li>PullRequest里有messageQueue和processQueue，其中messageQueue负责拉取消息，拉取到后，将消息存入processQueue，进行处理。 存入后就可以清空messageQueue，继续拉取了</li><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-6.png" alt=""></li></ul></li></ul><hr><h2 id="文件存储">文件存储</h2><ul><li>Broker接收到消息后是如何把消息进行存储的</li><li>最终存储的文件<ul><li>commitLog：消息存储目录</li><li>config：运行期间一些配置信息</li><li>consumerqueue：消息消费队列存储目录</li><li>index：消息索引文件存储目录</li><li>abort：如果存在改文件寿命Broker非正常关闭</li><li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、 consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳</li></ul></li><li>messageStore就是负责消息存储的核心组件</li><li>消息存储的入口在：DefaultMessageStore.putMessage</li><li>commitLog写入<ul><li>CommitLog的doAppend方法就是Broker写入消息的实际入口</li><li>这个方法最终会把消息追加到MappedFile映射的一块内存里，并没有直接写入磁盘</li><li>写入消息的过程是串行的，一次只会允许一个线程写入</li></ul></li><li>分发ConsumeQueue和IndexFile<ul><li>当CommitLog写入一条消息后，在DefaultMessageStore的start方法中，会启动一个后台线程reputMessageService每隔1毫秒就会去拉取CommitLog中最新更新的一批消息，然后分别转发到ComsumeQueue和IndexFile里去</li><li>如果服务异常宕机，会造成CommitLog和ConsumeQueue、IndexFile文件不一致，有消息写入CommitLog后，没有分发到索引文件，这样消息就丢失了</li><li>DefaultMappedStore的load方法提供了恢复索引文件的方法，入口在load方法</li></ul></li><li>文件同步刷盘与异步刷盘：CommitLog.submitFlushRequest<ul><li>同步刷盘也是使用异步机制实现的<ul><li>刷盘是一个很重的操作，所以，RocketMQ即便是同步刷盘，也要对刷盘次数精打细算<ul><li>单条消息，那么直接将commitlog刷盘即可</li><li>批量消息，RockeMQ会先收集这一批次消息的刷盘请求，再进行一次统一的刷盘操作</li><li>一批消息有可能会跨两个commitlog文件，所以在刷盘时，要严格计算commitlog文件的刷盘次数</li></ul></li></ul></li><li>异步刷盘<ul><li>通过RocketMQ自己实现的一个CountDownLatch2提供了线程阻塞，使用CAS来驱动CountDownLatch2的countDown操作</li><li>每来一个消息就启动一次CAS，成功后，调用一次countDown</li><li>这个CountDownLatch2在CountDownLatch的基础上，增加实现了reset功能，实现了对象的重用</li></ul></li><li>TransientStorePoolEnable。如果开启了堆外内存，会在启动时申请一个跟CommitLog文件大小一致的堆外内存，这部分内存就可以确保不会被交换到虚拟内存中</li></ul></li><li>CommigLog主从复制：CommitLog.submitReplicaRequest<ul><li>RocketMQ整体是基于Netty实现的网络请求，而在主从复制这一块，却放弃了Netty框架，转而使用更轻量级的Java的NIO来构建</li><li>在主要的HAService中，会在启动过程中启动三个守护进程<ul><li>其中与Master相关的是acceptSocketService和groupTransferService<ul><li>acceptSocketService主要负责维护Master与Slave之间的TCP连接</li><li>groupTransferService主要与主从同步复制有关</li></ul></li><li>而slave相关的则是haClient</li></ul></li></ul></li><li>过期文件删除：DefaultMessageStore.addScheduleTask -&gt; DefaultMessageStore.this.cleanFilesPeriodically<ul><li>Broker会启动后台线程，每60秒，检查CommitLog、ConsumeQueue文件<ul><li>然后对超过72小时的数据进行删除</li><li>默认情况下， RocketMQ只会保存3天内的数据</li><li>可以通过fileReservedTime来配置</li></ul></li><li>他删除时，并不会检查消息是否被消费了</li></ul></li><li>整个文件存储的核心入口在DefaultMessageStore的start方法中</li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-7.png" alt=""></p><hr><h2 id="延迟消息">延迟消息</h2><ul><li>延迟消息的核心使用方法就是在Message中设定一个MessageDelayLevel参数，对应18个延迟级别</li><li>然后Broker中会创建一个默认的Schedule_Topic主题，这个主题下有18个队列，对应18个延迟级别</li><li>消息发过来之后，会先把消息存入Schedule_Topic主题中对应的队列<ul><li>等延迟时间到了，再转发到目标队列，推送给消费者进行消费</li></ul></li><li>延迟消息的处理入口在scheduleMessageService， 他会在broker启动时也一起加载</li><li>消息写入：CommitLog.putMessage<ul><li>在CommitLog写入消息时，会判断消息的延迟级别，然后修改Message的Topic和Queue，达到转储Message的目的</li></ul></li><li>消息转储到目标Topic：scheduleMessageService<ul><li>这个服务只在master节点上启动，而在slave节点上会主动关闭这个服务</li><li>由于RocketMQ的主从节点支持切换，所以就需要考虑这个服务的幂等性<ul><li>在节点切换为slave时就要关闭服务，切换为master时就要启动服务</li><li>即便节点多次切换为master，服务也只启动一次：通过一个CAS操作来保证服务的启动状态</li><li>这个CAS操作还保证了在后面，同一时间只有一个DeliverDelayedMessageTimerTask执行</li></ul></li><li>ScheduleMessageService会每隔1秒钟执行一个executeOnTimeup任务，将消息从延迟队列中写入正常Topic中：ScheduleMessageService -&gt; DeliverDelayedMessageTimerTask.executeOnTimeup</li></ul></li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-8.png" alt=""></p><hr><h2 id="长轮询机制">长轮询机制</h2><ul><li>RocketMQ对消息消费者提供了Push推模式和Pull拉模式两种消费模式<ul><li>但是这两种消费模式的本质其实都是Pull拉模式</li><li>Push模式可以认为是一种定时的Pull机制</li></ul></li><li>长轮询机制简单来说，就是当Broker接收到Consumer的Pull请求时，判断如果没有对应的消息，不用直接给Consumer响应 (给响应也是个空的，没意义)，而是就将这个Pull请求给缓存起来<ul><li>当Producer发送消息过来时，增加一个步骤去检查是否有对应的已缓存的Pull请求，如果有，就及时将请求从缓存中拉取出来，并将消息通知给Consumer</li></ul></li></ul><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-9.png" alt=""></p><hr><p><img src="/static/IT/RocketMQ/RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84-10.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;NameServer的结构&lt;/li&gt;
&lt;li&gt;Broker的结构&lt;/li&gt;
&lt;li&gt;Netty服务注册框架&lt;/li&gt;
&lt;li&gt;RocketMQ的同步结果推送与异步结果推送&lt;/li&gt;
&lt;li&gt;Broker心跳注册过程&lt;/li&gt;
&lt;li&gt;Producer发送消息过程</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-消息类型&amp;ACL</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-xiao-xi-lei-xing-acl/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-xiao-xi-lei-xing-acl/</id>
    <published>2024-09-09T02:30:00.000Z</published>
    <updated>2024-09-09T02:31:03.069Z</updated>
    
    <content type="html"><![CDATA[<ul><li>消息类型</li><li>ACL 权限控制</li></ul><hr><h2 id="消息类型">消息类型</h2><ul><li>顺序消息<ul><li>保证的是消息的局部有序，而不是全局有序</li><li>消息发送者会采取Round Robin轮询方式把消息发送到不同的 MessageQueue (分区队列)<ul><li>消费者消费的时候也从多个MessageQueue上拉取消息，这种情况下消息是不能保证顺序的</li><li>而只有当一组有序的消息发送到同一个MessageQueue上时，才能利用MessageQueue先进先出的特性保证这一组消息有序</li><li>MessageListenerConcurrently这个消息监听器则不会锁队列，每次都是从多个Message中取一批数据（默认不超过32条）。因此也无法保证消息有序</li></ul></li><li>消费者会从多个消息队列上去拿消息<ul><li>这时虽然每个消息队列上的消息是有序的，但是多个队列之间的消息仍然是乱序的</li><li>消费者端要保证消息有序，就需要按队列一个一个来取消息，即取完一个队列的消息后，再去取下一个队列的消息</li><li>而给consumer注入的MessageListenerOrderly对象，在RocketMQ内部就会通过锁队列的方式保证消息是一个一个队列来取的</li></ul></li></ul></li><li>广播消息</li><li>延迟消息：<code>Message#setDelayTimeLevel</code><ul><li>在调用producer.send方法后，消息并不会立即发送出去，而是会等一段时间再发送出去</li><li>只支持18个固定的延迟级别（18种消息队列）</li></ul></li><li>批量消息<ul><li>将多条消息合并成一个批量消息，一次发送出去</li><li>如果批量消息大于1MB就不要用一个批次发送，而要拆分成多个批次消息发送<ul><li>实际最大的限制是4MB</li></ul></li><li>这些消息应该有相同的Topic，相同的waitStoreMsgOK</li><li>而且不能是延迟消息、事务消息等</li></ul></li><li>过滤消息<ul><li>可以使用Message的Tag属性来简单快速的过滤信息</li><li>一个应用可以就用一个Topic，而应用中的不同业务就用TAG来区分</li><li>可以使用SQL表达式来对消息进行过滤：<code>MessageSelector#bySql</code><ul><li>只有推模式的消费者可以使用SQL过滤</li></ul></li></ul></li><li>事务消息<ul><li><code>TransactionMQProducer -&gt; TransactionListener</code></li><li>事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性<ul><li>但是并不保证消费者本地事务的原子性</li></ul></li><li>事务消息不支持延迟消息和批量消息</li><li>默认将单个消息的检查次数限制为 15 次 <code>transactionCheckMax</code><ul><li>超过则 Broker 将丢弃此消息，默认情况下同时打印错误日志 <code>AbstractTransactionCheckListener</code></li></ul></li><li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查<ul><li>用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制<ul><li>该参数优先于 transactionMsgTimeout 参数</li></ul></li></ul></li><li>事务性消息可能不止一次被检查或消费</li><li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定<ul><li>如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制</li></ul></li><li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享<ul><li>事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者</li></ul></li><li>事务消息的实现机制<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B-ACL-1.png" alt=""><ul><li>在发送消息时，会将消息转为一个half半消息，并存入RocketMQ内部的一个 RMQ_SYS_TRANS_HALF_TOPIC 这个Topic，这样对消费者是不可见的</li><li>再经过一系列事务检查通过后，再将消息转存到目标Topic，这样对消费者就可见了</li></ul></li></ul></li><li>事务消息的作用<ul><li>事务消息只保证了分布式事务的一半</li><li>对于复杂的分布式事务，RocketMQ提供的事务消息也是目前业内最佳的降级方案</li></ul></li></ul></li></ul><hr><h2 id="ACL-权限控制">ACL 权限控制</h2><ul><li>权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制</li><li>用户在使用RocketMQ权限控制时，可以在Client客户端通过 RPCHook注入AccessKey和SecretKey签名<ul><li>同时，将对应的权限控制属性（包括Topic访问权限、IP白名单和AccessKey和SecretKey签名等）设置在<code>$ROCKETMQ_HOME/conf/plain_acl.yml</code>的配置文件中</li></ul></li><li>Broker端对AccessKey所拥有的权限进行校验，校验不过，抛出异常</li><li>Broker端要在broker.conf中打开acl的标志<ul><li>这个配置文件是热加载的，也就是说要修改配置时，只要修改配置文件就可以了，不用重启Broker服务</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;消息类型&lt;/li&gt;
&lt;li&gt;ACL 权限控制&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;消息类型&quot;&gt;消息类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序消息
&lt;ul&gt;
&lt;li&gt;保证的是消息的局部有序，而不是全局有序&lt;/li&gt;
&lt;li&gt;消息发送者会采取Round Ro</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-基础</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-ji-chu/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-ji-chu/</id>
    <published>2024-09-09T02:27:00.000Z</published>
    <updated>2024-09-09T02:28:22.884Z</updated>
    
    <content type="html"><![CDATA[<ul><li>RocketMQ 集群架构<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E5%9F%BA%E7%A1%80-1.png" alt=""></li><li>Producer：消息生产者集群。通常是业务系统中的一个功能模块。</li><li>Consumer：消息消费者集群。通常也是业务系统中的一个功能模块。</li><li>Broker：实际处理消息存储、转发等服务的核心组件。</li><li>NameServer : 提供轻量级的Broker路由服务。 管理Broker<ul><li>所以我们要启动RocketMQ服务，需要先启动NameServer。</li></ul></li><li>Topic：区分消息的种类；<ul><li>一个发送者可以发送消息给一个或者多个Topic</li><li>一个消息的接收者可以订阅一个或者多个Topic消息</li></ul></li><li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li><li>这种主从结构是只做数据备份，没有容灾功能</li></ul></li><li>Dledger 高可用集群：基于Raft协议<ul><li>修改conf/dleger下的配置文件</li></ul></li><li>系统参数调优<ul><li>配置RocketMQ的JVM内存大小 <code>runbroker.sh</code><ul><li><code>-XX:+UseG1GC</code> 使用G1垃圾回收器</li><li><code>-XX:G1HeapRegionSize=16m</code> 将G1的region块大小设为16M</li><li><code>-XX:G1ReservePercent</code> 在G1的老年代中预留25%空闲内存</li><li><code>-XX:InitiatingHeapOccupancyPercent=30</code> 当堆内存的使用率达到30%之后就会启动G1垃圾回收器尝试回收垃圾</li></ul></li><li>RocketMQ的其他一些核心参数<ul><li><code>sendMessageThreadPoolNums=16</code> RocketMQ内部用来发送消息的线程池的线程数量是16个</li></ul></li><li>Linux内核参数定制<ul><li>ulimit，需要进行大量的网络通信和磁盘IO</li><li>vm.extra_free_kbytes，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟</li><li>vm.min_free_kbytes，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁</li><li>vm.max_map_count，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值</li><li>vm.swappiness，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟</li><li>File descriptor limits，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350<ul><li><code>/proc/sys/vm</code></li></ul></li><li>另外，RocketMQ的bin目录下有个<code>os.sh</code>里面设置了RocketMQ建议的系统内核参数</li></ul></li></ul></li><li>RocketMQ消息转发模型<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E5%9F%BA%E7%A1%80-2.png" alt=""></li><li>消息模型（Message Model）<ul><li>RocketMQ 主要由 Producer、Broker、Consumer 三部分组成</li><li>Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息</li><li>Broker 在实际部署过程中对应一台服务器<ul><li>每个 Broker 可以存储多个Topic的消息，每个Topic 的消息也可以分片存储于不同的 Broker</li></ul></li><li>Message Queue 用于存储消息的物理地址<ul><li>每个Topic中的消息地址存储于多个 Message Queue 中</li></ul></li><li>ConsumerGroup 由多个Consumer 实例构成</li></ul></li><li>消息生产者（Producer）<ul><li>一个消息生产者会把业务应用系统里产生的消息发送到broker服务器</li><li>同步发送、异步发送、顺序发送、单向发送<ul><li>同步和异步方式均需要Broker返回确认信息，单向发送不需要</li></ul></li><li>生产者中，会把同一类Producer组成一个集合，叫做生产者组<ul><li>同一组的Producer被认为是发送同一类消息且发送逻辑一致</li></ul></li></ul></li><li>消息消费者（Consumer）<ul><li>负责消费消息，一般是后台系统负责异步消费</li><li>一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序</li><li>拉取式消费<ul><li>拉取式消费的应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程</li></ul></li><li>推动式消费<ul><li>推动式消费模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高</li></ul></li><li>消费者同样会把同一类Consumer组成一个集合，叫做消费者组<ul><li>这类Consumer通常消费同一类消息且消费逻辑一致</li><li>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易</li><li>消费者组的消费者实例必须订阅完全相同的Topic</li></ul></li><li>集群消费模式下,  相同Consumer Group的每个Consumer实例平均分摊消息</li><li>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息</li></ul></li><li>主题（Topic）<ul><li>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位</li><li>Topic只是一个逻辑概念，并不实际保存消息</li><li>同一个Topic下的消息，会分片保存到不同的Broker上，而每一个分片单位，就叫做MessageQueue</li><li>MessageQueue是一个具有FIFO特性的队列结构，生产者发送消息与消费者消费消息的最小单位</li></ul></li><li>代理服务器（Broker Server）<ul><li>消息中转角色，负责存储消息、转发消息<ul><li>负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备</li><li>也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等</li></ul></li><li>Broker Server是RocketMQ真正的业务核心，包含了多个重要的子模块<ul><li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求</li><li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li><li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能</li><li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步</li><li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务</li></ul></li><li>RocketMQ中有两种Broker架构模式<ul><li>普通集群<ul><li>这种集群模式下会给每个节点分配一个固定的角色</li><li>master负责响应客户端的请求，并存储消息</li><li>slave则只负责对master的消息进行同步保存，并响应部分客户端的读请求</li><li>消息同步方式分为同步同步和异步同步</li><li>这种集群模式下各个节点的角色无法进行切换<ul><li>也就是说，master节点挂了，这一组Broker就不可用了</li></ul></li></ul></li><li>Dledger高可用集群<ul><li>集群会随机选出一个节点作为master<ul><li>当master节点挂了后，会从slave中自动选出一个节点升级成为master</li></ul></li><li>完成master节点往slave节点的消息同步</li></ul></li></ul></li></ul></li><li>名字服务（Name Server）<ul><li>名称服务充当路由消息的提供者</li><li>Broker Server会在启动时向所有的Name Server注册自己的服务信息<ul><li>后续通过心跳请求的方式保证这个服务信息的实时性</li></ul></li><li>生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表</li><li>多个Namesrv实例组成集群，但相互独立，没有信息交换<ul><li>这种特性也就意味着NameServer中任意的节点挂了，只要有一台服务节点正常，整个路由服务就不会有影响</li></ul></li></ul></li><li>消息（Message）<ul><li>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题Topic</li><li>RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key<ul><li>系统提供了通过Message ID和Key查询消息的功能</li></ul></li><li>并且Message上有一个为消息设置的标志，Tag标签<ul><li>用于同一主题下区分不同类型的消息</li><li>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;RocketMQ 集群架构
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/static/IT/RocketMQ/RocketMQ-%E5%9F%BA%E7%A1%80-1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;Producer：消息生产者集群。通常是业务系统中的</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-核心原理</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-he-xin-yuan-li/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-he-xin-yuan-li/</id>
    <published>2024-09-09T02:19:00.000Z</published>
    <updated>2024-09-09T02:23:49.864Z</updated>
    
    <content type="html"><![CDATA[<ul><li>读队列与写队列</li><li>消息持久化</li><li>过期文件删除</li><li>高效文件写<ul><li>零拷贝</li><li>顺序写</li><li>刷盘机制</li></ul></li><li>消息主从复制</li><li>负载均衡</li><li>消息重试</li><li>死信队列</li><li>消息幂等</li><li>Dledger 集群<ul><li>选举</li><li>消息同步</li></ul></li></ul><hr><h2 id="读队列与写队列">读队列与写队列</h2><ul><li>通常在运行时，都需要设置读队列=写队列</li><li>读写分离<ul><li>写队列会真实的创建对应的存储文件，负责消息写入</li><li>读队列会记录Consumer的Offset，负责消息读取</li></ul></li><li>在往写队列里写Message时，会同步写入到一个对应的读队列中<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-1.png" alt=""></li></ul></li><li>如果写队列大于读队列，就会有一部分写队列无法写入到读队列中，这一部分的消息就无法被读取，就会造成消息丢失（消息存入了，但是读不出来）</li><li>如果写队列小于读队列，那就有一部分读队列里是没有消息写入的。如果有一个消费者被分配的是这些没有消息的读队列，那这些消费者就无法消费消息，造成消费者空转，极大的浪费性能</li><li>对Topic的MessageQueue进行缩减的时候，可以考虑将读写队列设置为不一致<ul><li>例如原来四个队列，现在要缩减成两个队列</li><li>如果立即缩减读写队列，那么被缩减的MessageQueue上没有被消费的消息，就会丢失</li><li>这时，可以先缩减写队列，待空出来的读队列上的消息都被消费完了之后，再来缩减读队列，这样就可以比较平稳的实现队列缩减了</li></ul></li></ul><hr><h2 id="消息持久化">消息持久化</h2><ul><li>RocketMQ消息直接采用磁盘文件保存消息，默认路径在<code>${user_home}/store</code>目录（<code>broker.conf</code>）</li><li>存储文件主要分为三个部分<ul><li>CommitLog：存储消息的元数据<ul><li>所有消息都会顺序存入到CommitLog文件当中</li><li>CommitLog由多个文件组成，每个文件固定大小1G</li><li>以第一条消息的偏移量为文件名</li></ul></li><li>ConsumerQueue：存储消息在CommitLog的索引<ul><li>一个MessageQueue一个文件</li><li>记录当前MessageQueue被哪些消费者组消费到了哪一条CommitLog</li></ul></li><li>IndexFile<ul><li>为了消息查询提供了一种通过key或时间区间来查询消息的方法</li><li>这通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li></ul></li><li>CommitLog文件和ConsumeQueue文件都是以偏移量命名</li></ul></li><li>还有几个辅助的存储文件<ul><li>checkpoint：数据存盘检查点<ul><li>里面主要记录commitlog文件、ConsumeQueue文件以及IndexFile文件最后一次刷盘的时间戳</li></ul></li><li><code>config/*.json</code>：这些文件是将RocketMQ的一些关键配置信息进行存盘保存<ul><li>例如Topic配置、消费者组配置、消费者组消息偏移量Offset 等等一些信息</li></ul></li><li>abort：这个文件是RocketMQ用来判断程序是否正常关闭的一个标识文件<ul><li>正常情况下，会在启动时创建，而关闭服务时删除</li><li>但是如果遇到一些服务器宕机，这个abort文件就不会删除</li><li>因此RocketMQ就可以判断上一次服务是非正常关闭的，后续就会做一些数据恢复的操作</li></ul></li></ul></li><li>整体的消息存储结构<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-2.png" alt=""></li></ul></li><li>CommitLog文件存储所有消息实体<ul><li>所有生产者发过来的消息，都会无差别的依次存储到Commitlog文件当中<ul><li>这样的好处是可以减少查找目标文件的时间，让消息以最快的速度落盘</li><li>对比Kafka存文件时，需要寻找消息所属的Partition文件，再完成写入，当Topic比较多时，这样的Partition寻址就会浪费比较多的时间，所以Kafka不太适合多Topic的场景</li><li>而RocketMQ的这种快速落盘的方式在多Topic场景下，优势就比较明显</li></ul></li><li>文件结构：CommitLog的文件大小是固定的，但是其中存储的每个消息单元长度是不固定的<ul><li>所以RocketMQ在每次存CommitLog文件时，都会去检查当前CommitLog文件空间是否足够<ul><li>如果不够的话，就重新创建一个CommitLog文件</li><li>文件名为当前消息的偏移量</li></ul></li></ul></li></ul></li><li>ConsumeQueue文件主要是加速消费者的消息索引<ul><li>他的每个文件夹对应RocketMQ中的一个MessageQueue<ul><li>文件夹下的文件记录了每个MessageQueue中的消息在CommitLog文件当中的偏移量</li><li>这样，消费者通过ComsumeQueue文件，就可以快速找到CommitLog文件中感兴趣的消息记录</li><li>而消费者在ConsumeQueue文件当中的消费进度，会保存在<code>config/consumerOffset.json</code>文件当中</li></ul></li><li>文件结构：每个ConsumeQueue文件固定由30万个固定大小20byte的数据块组成，数据块的内容包括<ul><li>msgPhyOffset (8byte，消息在文件中的起始位置)</li><li>msgSize (4byte，消息在文件中占用的长度)</li><li>msgTagCode (8byte，消息的tag的Hash值)</li></ul></li></ul></li><li>IndexFile文件主要是辅助消息检索<ul><li>消费者进行消息消费时，通过ConsumeQueue文件就足够完成消息检索了，但是如果要按照MeessageId或者MessageKey来检索文件，比如RocketMQ管理控制台的消息轨迹功能，ConsumeQueue文件就不够用了</li><li>他的文件名比较特殊，不是以消息偏移量命名，而是用的时间命名</li><li>文件结构：也是一个固定大小的文件<ul><li>indexHeader (固定40byte)</li><li>slot (固定500W个，每个固定20byte)</li><li>index (最多<code>500W*4</code>个，每个固定20byte)</li></ul></li></ul></li></ul><hr><h2 id="过期文件删除">过期文件删除</h2><ul><li>判断过期文件：唯一标准就是非当前写文件的保留时间（<code>broker.conf -&gt; fileReservedTime</code>）<ul><li>如果超过了一定的保留时间，那么这些文件都会被认为是过期文件，随时可以删除</li><li>并不关心文件当中的消息是否被消费过<ul><li>所以，RocketMQ的消息堆积也是有时间限度的</li></ul></li></ul></li><li>删除过期文件<ul><li>内部有一个定时任务，对文件进行扫描，并且触发文件删除的操作<ul><li><code>broker.conf -&gt; deleteWhen</code>，默认是凌晨四点</li></ul></li><li>还会检查服务器的磁盘空间是否足够，如果磁盘空间的使用率达到一定的阈值，也会触发过期文件删除<ul><li>broker的磁盘空间不要少于4</li></ul></li></ul></li></ul><hr><h2 id="高效文件写">高效文件写</h2><h3 id="零拷贝">零拷贝</h3><ul><li>所谓的零拷贝技术，其实并不是不拷贝，而是要尽量减少CPU拷贝</li><li>引入DMA拷贝之后，在读写请求的过程中，CPU不再需要参与具体的工作<ul><li>DMA可以独立完成数据在系统内部的复制</li><li>但是，数据复制过程中，依然需要借助数据总进线<ul><li>当系统内的IO操作过多时，还是会占用过多的数据总线，造成总线冲突，最终还是会影响数据读写性能</li></ul></li></ul></li><li>为了避免DMA总线冲突对性能的影响，后来又引入了Channel通道的方式<ul><li>Channel，是一个完全独立的处理器，专门负责IO操作</li><li>既然是处理器，Channel就有自己的IO指令，与CPU无关，他也更适合大型的IO操作，性能更高</li></ul></li><li>mmap：<code>FileChannel#map</code><ul><li>mmap机制适合操作小文件，如果文件太大，映射信息也会过大，容易造成很多问题</li><li>通常mmap机制建议的映射文件大小不要超过2G</li><li>RocketMQ的CommitLog文件保持在1G固定大小，也是为了方便文件映射</li><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-3.png" alt=""></li></ul></li><li>sendFile：<code>FileChannel#transferTo</code><ul><li>在拷贝过程中，并不直接拷贝文件的内容，而是只拷贝一个带有文件位置和长度等信息的文件描述符FD<ul><li>这样就大大减少了需要传递的数据</li></ul></li><li>而真实的数据内容，会交由DMA控制器，从页缓存中打包异步发送到socket中</li><li>sendfile机制在内核态直接完成了数据的复制，不需要用户态的参与，所以这种机制的传输效率是非常稳定的</li><li>sendfile机制非常适合大数据的复制转移</li><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-4.png" alt=""></li></ul></li></ul><h3 id="顺序写">顺序写</h3><ul><li>在磁盘中提前申请一块连续的磁盘空间<ul><li>每次写数据时，就可以避免这些寻址操作，直接在之前写入的地址后面接着写就行</li></ul></li><li>顺序写的性能基本能够达到内存级别</li></ul><h3 id="刷盘机制">刷盘机制</h3><ul><li>在操作系统层面<ul><li>当应用程序写入一个文件时，文件内容并不会直接写入到硬件当中，而是会先写入到操作系统中的一个缓存PageCache中<ul><li>PageCache缓存以4K大小为单位，缓存文件的具体内容</li><li>这些写入到PageCache中的文件，在应用程序看来，是已经完全落盘保存好了的</li><li>但是，本质上，PageCache依然是内存状态，所以一断电就会丢失</li><li>因此，需要将内存状态的数据写入到磁盘当中，这样数据才能真正完成持久化，断电也不会丢失<ul><li>这个过程就称为刷盘</li></ul></li></ul></li><li>PageCache是源源不断产生的，操作系统只会在某些特定的时刻将PageCache写入到磁盘<ul><li>正常关机时</li><li>当 Dirty Page (脏页) 的比例达到一定的阈值时（对于有数据修改的PageCache，会标记为Dirty状态）</li></ul></li><li>可以通过/proc/meminfo文件查看到Page Cache的状态</li><li>fsync：可以让应用程序完成PageCache的强制刷盘</li></ul></li><li>RocketMQ对于何时进行刷盘，也设计了两种刷盘机制，同步刷盘和异步刷盘<ul><li><code>broker.conf -&gt; flushDiskType</code></li><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-5.png" alt=""></li><li>同步刷盘：在返回写成功状态时，消息已经被写入磁盘<ul><li>消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘</li><li>然后等待刷盘完成</li><li>刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态</li></ul></li><li>异步刷盘：在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE<ul><li>写操作的返回快，吞吐量大</li><li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入</li></ul></li><li>同步刷盘机制会更频繁的调用fsync，所以吞吐量相比异步刷盘会降低，但是数据的安全性会得到提高</li></ul></li></ul><hr><h2 id="消息主从复制">消息主从复制</h2><ul><li>同步复制：等Master和Slave都写入消息成功后才反馈给客户端写入成功的状态<ul><li>如果Master节点故障，Slave上有全部的数据备份，这样容易恢复数据</li><li>但是同步复制会增大数据写入的延迟，降低系统的吞吐量</li></ul></li><li>异步复制：只要master写入消息成功，就反馈给客户端写入成功的状态<ul><li>然后再异步的将消息复制给Slave节点</li><li>系统拥有较低的延迟和较高的吞吐量</li><li>但是如果master节点故障，而有些数据没有完成复制，就会造成数据丢失</li></ul></li><li><code>broker.conf -&gt; brokerRole</code><ul><li>ASYNC_MASTER、 SYNC_MASTER、SLAVE</li></ul></li></ul><hr><h2 id="负载均衡">负载均衡</h2><ul><li>Producer 负载均衡<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-6.png" alt=""></li><li>Producer发送消息时，默认会轮询目标Topic下的所有MessageQueue，并采用递增取模的方式往不同的MessageQueue上发送消息，以达到让消息平均落在不同的queue上的目的</li><li>由于MessageQueue是分布在不同的Broker上的，所以消息也会发送到不同的broker上</li><li>同时生产者在发送消息时，可以指定一个MessageQueueSelector<ul><li>通过这个对象来将消息发送到自己指定的MessageQueue上</li><li>这样可以保证消息局部有序</li></ul></li></ul></li><li>Consumer负载均衡： Consumer也是以MessageQueue为单位来进行负载均衡<ul><li>集群模式<ul><li>每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可</li><li>RocketMQ采用主动拉取的方式拉取并消费消息<ul><li>在拉取的时候需要明确指定拉取哪一条message queue</li></ul></li><li>每当实例的数量有变更，都会触发一次所有实例的负载均衡<ul><li>这时候会按照queue的数量和实例的数量平均分配queue给每个实例</li></ul></li><li>每次分配时，都会将MessageQueue和消费者ID进行排序后，再用不同的分配算法进行分配</li><li>内置的分配的算法共有六种，分别对应AllocateMessageQueueStrategy下的六种实现类<ul><li>可以在consumer中直接set来指定。默认情况下使用的是最简单的平均分配策略</li></ul></li></ul></li><li>广播模式<ul><li>每一条消息都会投递给订阅了Topic的所有消费者实例，所以也就没有消息分配这一说</li><li>在实现上，就是在Consumer分配Queue时，所有Consumer都分到所有的Queue</li><li>实现的关键是将消费者的消费偏移量不再保存到broker当中<ul><li>而是保存到客户端当中，由客户端自行维护自己的消费偏移量</li></ul></li></ul></li></ul></li><li>集群模式分配算法<ul><li>AllocateMachineRoomNearby： 将同机房的Consumer和Broker优先分配在一起<ul><li>可以通过一个machineRoomResolver对象来定制Consumer和Broker的机房解析规则</li><li>然后还需要引入另外一个分配策略来对同机房的Broker和Consumer进行分配<ul><li>一般也就用简单的平均分配策略或者轮询分配策略</li></ul></li></ul></li><li>AllocateMessageQueueAveragely（默认）：平均分配。将所有MessageQueue平均分给每一个消费者</li><li>AllocateMessageQueueAveragelyByCircle： 轮询分配。轮流的给一个消费者分配一个MessageQueue</li><li>AllocateMessageQueueByConfig： 不分配，直接指定一个messageQueue列表<ul><li>类似于广播模式，直接指定所有队列</li></ul></li><li>AllocateMessageQueueByMachineRoom：按逻辑机房的概念进行分配<ul><li>又是对BrokerName和ConsumerIdc有定制化的配置</li></ul></li><li>AllocateMessageQueueConsistentHash：一致性哈希策略<ul><li>只需要指定一个虚拟节点数，是用的一个哈希环的算法</li><li>虚拟节点是为了让Hash数据在换上分布更为均匀</li></ul></li></ul></li></ul><hr><h2 id="消息重试">消息重试</h2><ul><li>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置<ul><li><code>MessageListener#consume</code></li><li>返回 Action.ReconsumeLater（推荐） 消息重试</li><li>返回 Action.CommitMessage 消费失败后不重试</li><li>返回 null</li><li>抛出异常</li></ul></li><li>处理重试消息<ul><li>重试的消息会进入一个 “%RETRY%”+ConsumeGroup 的队列中</li><li>默认允许每条消息最多重试16次<ul><li>这个重试时间跟延迟消息的延迟级别是对应的</li><li>不过取的是延迟级别的后16级别</li></ul></li><li><code>consumer#setMaxReconsumeTimes</code> 定制重试次数<ul><li>当定制的重试次数超过16次后，消息的重试时间间隔均为2小时</li></ul></li><li>如果消息重试16次后仍然失败，消息将不再投递。转为进入死信队列</li><li>一条消息无论重试多少次，这些重试消息的MessageId始终都是一样的<ul><li>在4.9.1版本中，每次重试MessageId都会重建</li></ul></li><li>配置覆盖<ul><li>消息最大重试次数的设置对相同GroupID下的所有Consumer实例有效</li><li>并且最后启动的Consumer会覆盖之前启动的Consumer的配置</li></ul></li></ul></li></ul><hr><h2 id="死信队列">死信队列</h2><ul><li>如果消息重试16次（<code>consumer#setMaxReconsumeTimes</code>）后仍然失败，消息将不再投递。转为进入死信队列</li><li>死信队列的名称是 %DLQ%+ConsumGroup</li><li>死信队列的特征<ul><li>一个死信队列对应一个ConsumGroup，而不是对应某个消费者实例</li><li>如果一个ConsumeGroup没有产生死信队列，RocketMQ就不会为其创建相应的死信队列</li><li>一个死信队列包含了这个ConsumeGroup里的所有死信消息，而不区分该消息属于哪个Topic</li><li>死信队列中的消息不会再被消费者正常消费</li><li>死信队列的有效期跟正常消息相同。默认3天（<code>broker.conf -&gt; fileReservedTime</code>）<ul><li>超过这个最长时间的消息都会被删除，而不管消息是否消费过</li></ul></li></ul></li><li>一般需要人工去查看死信队列中的消息，对错误原因进行排查<ul><li>然后对死信消息进行处理，比如转发到正常的Topic重新进行消费，或者丢弃</li></ul></li><li>默认创建出来的死信队列，他里面的消息是无法读取的，在控制台和消费者中都无法读取<ul><li>这些默认的死信队列，他们的权限 perm 被设置成了 2:禁读<ul><li>权限有三种：2:禁读，4:禁写，6:可读可写</li></ul></li><li>需要手动将死信队列的权限配置成 6，才能被消费</li></ul></li></ul><hr><h2 id="消息幂等">消息幂等</h2><ul><li>在MQ系统中，对于消息幂等有三种实现语义<ul><li>at most once 最多一次：每条消息最多只会被消费一次</li><li>at least once 至少一次：每条消息至少会被消费一次</li><li>exactly once 刚刚好一次：每条消息都只会确定的消费一次</li></ul></li><li>RocketMQ 只能保证 at least once，保证不了 exactly once<ul><li>所以，使用RocketMQ时，需要由业务系统自行保证消息的幂等性</li></ul></li><li>消息重复<ul><li>发送时消息重复<ul><li>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败</li><li>此时生产者意识到消息发送失败并尝试再次发送消息</li><li>消费者后续会收到两条内容相同并且 Message ID 也相同的消息</li></ul></li><li>投递时消息重复<ul><li>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断</li><li>为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息</li><li>消费者后续会收到两条内容相同并且 Message ID 也相同的消息</li></ul></li><li>负载均衡时消息重复：网络抖动、Broker 重启以及订阅方应用重启<ul><li>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息</li></ul></li></ul></li><li>处理方式：要在业务上自行来保证消息消费的幂等性<ul><li>RocketMQ的每条消息都有一个唯一的 MessageId，这个参数在多次投递的过程中是不会改变的</li><li>业务上可以用这个MessageId来作为判断幂等的关键依据</li><li>但是，这个MessageId是无法保证全局唯一的，也会有冲突的情况</li><li>所以在一些对幂等性要求严格的场景，最好是使用业务上唯一的一个标识比较靠谱</li><li>而这个业务标识可以使用Message的Key来进行传递</li></ul></li></ul><hr><h2 id="Dledger-集群">Dledger 集群</h2><ul><li>高可用集群：基于Raft，在RocketMQ的主从集群基础上，增加了自动选举的功能</li><li>Dledger集群主要包含两个功能<ul><li>从集群中选举产生master节点</li><li>优化master节点往slave节点的消息同步机制</li></ul></li></ul><h3 id="选举">选举</h3><ul><li>Dledger是使用Raft算法来进行节点选举<ul><li>节点有三个状态，Leader，follower 和 candidate (候选人)<ul><li>正常运行的情况下，集群中会有一个leader，其他都是follower</li><li>follower只响应Leader和Candidate的请求</li><li>客户端的请求全部由Leader处理<ul><li>即使有客户端请求到了一个follower，也会将请求转发到leader</li></ul></li></ul></li><li>选举流程<ul><li>集群刚启动时，每个节点都是follower状态</li><li>之后集群内部会发送一个timeout信号</li><li>所有follower就转成candidate去拉取选票，获得大多数选票的节点选为leader，其他候选人转为follower</li><li>如果一个timeout信号发出时，没有选出leader，将会重新开始一次新的选举</li></ul></li><li>心跳<ul><li>Leader节点会往其他节点发送心跳信号，确认他的leader状态</li><li>然后follower会启动定时器，如果在指定时间内没有收到Leader的心跳，就会转为Candidate状态</li><li>然后向其他成员发起投票请求，如果收到半数以上成员的投票，则Candidate会晋升为Leader<ul><li>然后leader也有可能会退化成follower</li></ul></li></ul></li></ul></li><li>在Raft协议中，会将时间分为一些任意时间长度的时间片段，叫做term<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-7.png" alt=""></li><li>term会使用一个全局唯一，连续递增的编号作为标识，也就是起到了一个逻辑时钟的作用</li><li>在每一个term时间片里，都会进行新的选举，每一个Candidate都会努力争取成为leader<ul><li>获得票数最多的节点就会被选举为Leader</li></ul></li><li>被选为Leader的这个节点，在一个term时间片里就会保持leader状态<ul><li>保证在同一时间段内，集群中只会有一个Leader</li></ul></li><li>在某些情况下，选票可能会被各个节点瓜分，形成不了多数派，那这个term可能直到结束都没有leader<ul><li>直到下一个term再重新发起选举，这也就没有了Zookeeper中的脑裂问题</li></ul></li><li>在每次重新选举的过程中， leader也有可能会退化成为follower<ul><li>也就是说，在这个集群中， leader节点是会不断变化的</li></ul></li></ul></li><li>每次选举的过程中，每个节点都会存储当前term编号，并在节点之间进行交流时，都会带上自己的term编号<ul><li>如果一个节点发现他的编号比另外一个小，那么他就会将自己的编号更新为较大的那一个</li><li>如果leader或者candidate发现自己的编号不是最新的，他就会自动转成follower</li><li>如果接收到的请求term编号小于自己的编号，term将会拒绝执行</li></ul></li><li>在选举过程中，Raft协议会通过心跳机制发起leader选举<ul><li>节点都是从follower状态开始的，如果收到了来自leader或者candidate的心跳RPC请求，那他就会保持follower状态，避免争抢成为candidate</li><li>leader会往其他节点发送心跳信号，来确认自己的地位</li><li>如果follower一段时间(两个timeout信号)内没有收到Leader的心跳信号，他就会认为leader挂了，发起新一轮选举</li></ul></li><li>选举开始后，每个follower会增加自己当前的term，并将自己转为candidate<ul><li>然后向其他节点发起投票请求，请求时会带上自己的编号和term，也就是说都会默认投自己一票</li><li>之后candidate状态可能会发生以下三种变化<ul><li>赢得选举，成为leader<ul><li>如果它在一个term内收到了大多数的选票，将会在接下的剩余term时间内称为leader</li><li>然后就可以通过发送心跳确立自己的地位</li><li>每一个server在一个term内只能投一张选票，并且按照先到先得的原则投出)</li></ul></li><li>其他节点成为leader<ul><li>在等待投票时，可能会收到其他server发出心跳信号，说明其他leader已经产生了</li><li>这时通过比较自己的term编号和RPC过来的term编号<ul><li>如果比对方大，说明leader的term过期了，就会拒绝该RPC,并继续保持候选人身份</li><li>如果对方编号不比自己小,则承认对方的地位,转为follower</li></ul></li></ul></li><li>选票被瓜分,选举失败<ul><li>如果没有candidate获取大多数选票, 则没有leader产生</li><li>candidate们等待超时后发起另一轮选举</li><li>为了防止下一次选票还被瓜分, raft采用随机electiontimeout(随机休眠时间)的机制防止选票被持续瓜分</li><li>通过将timeout随机设为一段区间上的某个值, 因此很大概率会有某个candidate率先超时然后赢得大部分选票</li></ul></li></ul></li></ul></li><li>所以以三个节点的集群为例，选举过程会是这样的<ul><li>集群启动时，三个节点都是follower，发起投票后，三个节点都会给自己投票。这样一轮投票下来，三个节点的term都是1，是一样的，这样是选举不出Leader的</li><li>当一轮投票选举不出Leader后，三个节点会进入随机休眠，例如A休眠1秒，B休眠3秒，C休眠2秒</li><li>一秒后，A节点醒来，会把自己的term加一票，投为2。然后2秒时，C节点醒来，发现A的term已经是2，比自己的1大，就会承认A是Leader，把自己的term也更新为2。实际上这个时候，A已经获得了集群中的多数票，2票，A就会被选举成Leader。这样，一般经过很短的几轮选举，就会选举出一个Leader来</li><li>到3秒时，B节点会醒来，他也同样会承认A的term最大，他是Leader，自己的term也会更新为2。这样集群中的所有Candidate就都确定成了leader和follower</li><li>然后在一个任期内，A会不断发心跳给另外两个节点。当A挂了后，另外的节点没有收到A的心跳，就会都转化成Candidate状态，重新发起选举</li></ul></li></ul><h3 id="消息同步">消息同步</h3><p>Dledger还会采用Raft协议进行多副本的消息同步：</p><ul><li>使用Dledger集群后，数据主从同步会分为两个阶段，一个是uncommitted阶段，一个是commited阶段</li><li>Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态，然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件</li><li>接着Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger。然后如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态</li><li>再接下来， Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer，让他们把消息也标记为committed状态。这样，就基于Raft协议完成了两阶段的数据同步</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;读队列与写队列&lt;/li&gt;
&lt;li&gt;消息持久化&lt;/li&gt;
&lt;li&gt;过期文件删除&lt;/li&gt;
&lt;li&gt;高效文件写
&lt;ul&gt;
&lt;li&gt;零拷贝&lt;/li&gt;
&lt;li&gt;顺序写&lt;/li&gt;
&lt;li&gt;刷盘机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息主从复制&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-代码示例</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-dai-ma-shi-li/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-dai-ma-shi-li/</id>
    <published>2024-09-09T02:15:00.000Z</published>
    <updated>2024-09-09T02:15:41.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>消息发送者的固定步骤<ul><li>同步发送消息</li><li>异步发送消息</li><li>单向发送消息：只管把消息发出去</li></ul></li><li>消息消费者的固定步骤<ul><li>拉模式<ul><li>DefaultMQPullConsumerImpl 这个消费者类已标记为过期</li><li>替换的类是 DefaultLitePullConsumerImpl</li></ul></li><li>推模式</li></ul></li><li>顺序消息</li><li>广播消息</li><li>延迟消息</li><li>批量消息</li><li>过滤消息</li><li>事务消息</li><li>ACL 权限控制</li><li>SpringBoot 整合 RocketMQ</li></ul><hr><h2 id="消息发送者的固定步骤">消息发送者的固定步骤</h2><ol><li>创建消息生产者producer，并制定生产者组名</li><li>指定Nameserver地址</li><li>启动producer</li><li>创建消息对象，指定主题Topic、Tag和消息体</li><li>发送消息：同步发送、异步发送以及单向发送</li><li>关闭生产者producer</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"ProducerGroupName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span><span class="token string">"TagA"</span><span class="token punctuation">,</span><span class="token string">"OrderID188"</span><span class="token punctuation">,</span> <span class="token string">"Hello world"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_CHARSET</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 同步发送消息</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 异步发送消息</span>producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendAsyncFailed</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 单向发送消息</span>producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="消息消费者的固定步骤">消息消费者的固定步骤</h2><ol><li>创建消费者Consumer，制定消费者组名</li><li>指定Nameserver地址</li><li>订阅主题Topic和Tag</li><li>设置回调函数，处理消息<ul><li>拉模式；推模式（推模式也是由拉模式封装出来的）</li></ul></li><li>启动消费者consumer</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 拉模式</span><span class="token class-name">DefaultMQPullConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPullConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> mqs <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">fetchSubscribeMessageQueues</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageQueue</span> mq <span class="token operator">:</span> mqs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从每个 MQ 中拉消息，指定 offset 和 maxNums</span><span class="token class-name">PullResult</span> pullResult <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">pullBlockIfNotFound</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 该 MQ 中下一个消息的 offset</span><span class="token keyword">long</span> offset <span class="token operator">=</span> pullResult<span class="token punctuation">.</span><span class="token function">getNextBeginOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>pullResult<span class="token punctuation">.</span><span class="token function">getPullStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 如果该 MQ 中的消息没取完，应该继续取</span><span class="token punctuation">}</span><span class="token punctuation">}</span>consumer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 订阅-拉模式</span><span class="token class-name">DefaultLitePullConsumer</span> litePullConsumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultLitePullConsumer</span><span class="token punctuation">(</span><span class="token string">"lite_pull_consumer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span><span class="token constant">CONSUME_FROM_LAST_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> messageExts <span class="token operator">=</span> litePullConsumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 分派-拉模式</span><span class="token class-name">DefaultLitePullConsumer</span> litePullConsumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultLitePullConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> mqSet <span class="token operator">=</span> litePullConsumer<span class="token punctuation">.</span><span class="token function">fetchMessageQueues</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>mqSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// list -add-&gt; assignList</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> assignList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>assignList<span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span>assignList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> messageExts <span class="token operator">=</span> litePullConsumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">commitSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>litePullConsumer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 推模式</span><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"CID_JODIE_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"worker1:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span><span class="token constant">CONSUME_FROM_LAST_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 消费 msgs 之后确认已经消费完毕</span><span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="顺序消息">顺序消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 生产者</span><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"OrderTopicTest"</span><span class="token punctuation">,</span> <span class="token string">"order_"</span> <span class="token operator">+</span> orderId<span class="token punctuation">,</span> <span class="token string">"KEY"</span> <span class="token operator">+</span> orderId<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"order_"</span><span class="token operator">+</span>orderId<span class="token operator">+</span><span class="token string">" step "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_CHARSET</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> mqs<span class="token punctuation">,</span> <span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 根据传入的 arg (即 producer#send 的第二个参数，orderId) 选一个 MessageQueue</span><span class="token keyword">return</span> mqs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 消费者</span><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"localhost:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span><span class="token constant">CONSUME_FROM_LAST_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"OrderTopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 需要使用 MessageListenerOrderly 保证顺序性，而不是 MessageListenerConcurrently</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerOrderly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConsumeOrderlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeOrderlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>context<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 消费 msgs 后确认消费完毕</span><span class="token keyword">return</span> <span class="token class-name">ConsumeOrderlyStatus</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="广播消息">广播消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 消费者</span><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span><span class="token constant">CONSUME_FROM_LAST_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span><span class="token constant">BROADCASTING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 消费 msgs 后确认消费完毕</span><span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="延迟消息">延迟消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 生产者</span><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TestTopic"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Hello scheduled message "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>message<span class="token punctuation">.</span><span class="token function">setDelayTimeLevel</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="批量消息">批量消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span> messages<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="过滤消息">过滤消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// tag-生产者</span><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TagFilterTest"</span><span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span>  <span class="token string">"Hello world"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_CHARSET</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// tag-消费者</span><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TagFilterTest"</span><span class="token punctuation">,</span> <span class="token string">"TagA || TagC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 消费 msgs 后确认消费完毕</span><span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// sql-生产者</span><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"192.168.232.128:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"SqlFilterTest"</span><span class="token punctuation">,</span><span class="token string">"TagA"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"Hello RocketMQ"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_CHARSET</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msg<span class="token punctuation">.</span><span class="token function">putUserProperty</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// sql-消费者</span><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"SqlFilterTest"</span><span class="token punctuation">,</span><span class="token class-name">MessageSelector</span><span class="token punctuation">.</span><span class="token function">bySql</span><span class="token punctuation">(</span><span class="token string">"(TAGS is not null and TAGS in ('TagA', 'TagB'))"</span> <span class="token operator">+</span><span class="token string">"and (a is not null and a between 0 and 3)"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 消费 msgs 后确认消费完毕</span><span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="事务消息">事务消息</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionListener</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// COMMIT_MESSAGE ROLLBACK_MESSAGE UNKNOW</span>msg<span class="token punctuation">.</span><span class="token function">getTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事务ID</span><span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span><span class="token constant">COMMIT_MESSAGE</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// COMMIT_MESSAGE ROLLBACK_MESSAGE UNKNOW</span>msg<span class="token punctuation">.</span><span class="token function">getTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 事务ID</span><span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span><span class="token constant">COMMIT_MESSAGE</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TransactionListener</span> transactionListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionListenerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TransactionMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">"group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setExecutorService</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span>transactionListener<span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"KEY"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Hello RocketMQ "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_CHARSET</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="ACL-权限控制">ACL 权限控制</h2><ul><li><code>&lt;artifactId&gt;rocketmq-acl&lt;/artifactId&gt;</code></li><li><code>broker.conf -&gt; aclEnable=true</code></li><li><code>plan_acl.yml</code></li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#全局白名单，不受ACL控制 </span><span class="token comment">#通常需要将主从架构中的所有节点加进来 </span><span class="token key atrule">globalWhiteRemoteAddresses</span><span class="token punctuation">:</span><span class="token punctuation">-</span> 10.10.103.*<span class="token punctuation">-</span> 192.168.0.*<span class="token key atrule">accounts</span><span class="token punctuation">:</span><span class="token comment">#第一个账户</span><span class="token punctuation">-</span> <span class="token key atrule">accessKey</span><span class="token punctuation">:</span> RocketMQ  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> <span class="token number">12345678</span>   <span class="token key atrule">whiteRemoteAddress</span><span class="token punctuation">:</span>   <span class="token key atrule">admin</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token key atrule">defaultTopicPerm</span><span class="token punctuation">:</span> DENY <span class="token comment">#默认Topic访问策略是拒绝 </span>  <span class="token key atrule">defaultGroupPerm</span><span class="token punctuation">:</span> SUB <span class="token comment">#默认Group访问策略是只允许订阅 </span>  <span class="token key atrule">topicPerms</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> topicA=DENY <span class="token comment">#topicA拒绝</span>  <span class="token punctuation">-</span> topicB=PUB<span class="token punctuation">|</span>SUB <span class="token comment">#topicB允许发布和订阅消息</span>  <span class="token punctuation">-</span> topicC=SUB <span class="token comment">#topicC只允许订阅</span>  <span class="token key atrule">groupPerms</span><span class="token punctuation">:</span>  <span class="token comment"># the group should convert to retry topic</span>  <span class="token punctuation">-</span> groupA=DENY  <span class="token punctuation">-</span> groupB=PUB<span class="token punctuation">|</span>SUB  <span class="token punctuation">-</span> groupC=SUB<span class="token comment">#第二个账户，只要是来自192.168.1.*的IP，就可以访问所有资源 </span><span class="token punctuation">-</span> <span class="token key atrule">accessKey</span><span class="token punctuation">:</span> rocketmq2  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> <span class="token number">12345678</span>   <span class="token key atrule">whiteRemoteAddress</span><span class="token punctuation">:</span> 192.168.1.*  <span class="token comment"># if it is admin, it could access all resources </span>  <span class="token key atrule">admin</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="SpringBoot-整合-RocketMQ">SpringBoot 整合 RocketMQ</h2><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#NameServer地址 </span><span class="token key attr-name">rocketmq.name-server</span><span class="token punctuation">=</span><span class="token value attr-value">192.168.232.128:9876 </span><span class="token comment">#默认的消息生产者组 </span><span class="token key attr-name">rocketmq.producer.group</span><span class="token punctuation">=</span><span class="token value attr-value">springBootGroup</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 生产者</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringProducer</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">RocketMQTemplate</span> rocketMQTemplate<span class="token punctuation">;</span><span class="token comment">// 发送普通消息</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>rocketMQTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 发送事务消息</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">String</span> destination <span class="token operator">=</span>topic <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token string">"TagA"</span><span class="token punctuation">;</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> rocketMQTemplate<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> message<span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 事务消息监听器</span><span class="token annotation punctuation">@RocketMQTransactionListener</span><span class="token punctuation">(</span>rocketMQTemplateBeanName <span class="token operator">=</span> <span class="token string">"rocketMQTemplate"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTransactionImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQLocalTransactionListener</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">RocketMQLocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// COMMIT ROLLBACK UNKNOWN</span><span class="token comment">// SpringBoot 的消息对象中，并没有 transactionId 这个属性</span><span class="token keyword">return</span> <span class="token class-name">RocketMQLocalTransactionState</span><span class="token punctuation">.</span><span class="token constant">COMMIT</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">RocketMQLocalTransactionState</span> <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// COMMIT ROLLBACK UNKNOWN</span><span class="token keyword">return</span> <span class="token class-name">RocketMQLocalTransactionState</span><span class="token punctuation">.</span><span class="token constant">COMMIT</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 消费者</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>consumerGroup <span class="token operator">=</span> <span class="token string">"MyConsumerGroup"</span><span class="token punctuation">,</span> topic <span class="token operator">=</span> <span class="token string">"TestTopic"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConsumer</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received message : "</span><span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;消息发送者的固定步骤
&lt;ul&gt;
&lt;li&gt;同步发送消息&lt;/li&gt;
&lt;li&gt;异步发送消息&lt;/li&gt;
&lt;li&gt;单向发送消息：只管把消息发出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息消费者的固定步骤
&lt;ul&gt;
&lt;li&gt;拉模式
&lt;ul&gt;
&lt;li&gt;DefaultMQ</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-常见问题</title>
    <link href="https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-chang-jian-wen-ti/"/>
    <id>https://jxch.github.io/2024/09/09/architect/rocketmq/rocketmq-chang-jian-wen-ti/</id>
    <published>2024-09-09T02:10:00.000Z</published>
    <updated>2024-09-09T02:13:25.625Z</updated>
    
    <content type="html"><![CDATA[<ul><li>消息零丢失</li><li>消息顺序</li><li>消息积压</li><li>消息轨迹</li></ul><hr><h2 id="消息零丢失">消息零丢失</h2><ul><li>哪些环节会有丢消息的可能<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1.png" alt=""></li><li>1，2，4 三个场景都是跨网络的，而跨网络就肯定会有丢消息的可能</li><li>通常MQ存盘时都会先写入操作系统的缓存page cache中，然后再由操作系统异步的将消息写入硬盘<ul><li>这个中间有个时间差，就可能会造成消息丢失</li><li>如果服务挂了，缓存中还没有来得及写入硬盘的消息就会丢失</li></ul></li></ul></li><li>生产者使用事务消息机制保证消息零丢失<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2.png" alt="事务消息"></li><li>half 消息<ul><li>这个half消息是在订单系统进行下单操作前发送，并且对下游服务的消费者是不可见的</li><li>这个消息的作用更多的体现在确认RocketMQ的服务是否正常</li><li>half 消息如果写入失败了，可以在下单时给订单一个状态标记，然后等待MQ服务正常后再进行补偿操作，等MQ服务正常后重新下单通知下游服务</li></ul></li><li>订单系统写数据库失败<ul><li>可以另外找个地方把订单消息先缓存起来</li><li>然后给RocketMQ返回一个UNKNOWN状态<ul><li>这样RocketMQ就会过一段时间来回查事务状态</li></ul></li><li>可以在回查事务状态时再尝试把订单数据写入数据库，如果数据库这时候已经恢复了，那就能完整正常的下单，再继续后面的业务</li></ul></li><li>half消息写入成功后RocketMQ挂了<ul><li>未知状态的事务状态回查是由RocketMQ的Broker主动发起的</li><li>等RocketMQ恢复后，只要存储的消息没有丢失，RocketMQ就会再次继续状态回查的流程</li></ul></li><li>下单成功后如何优雅的等待支付成功<ul><li>可以用事务消息的状态回查机制来替代定时的任务</li><li>在下单时，给Broker返回一个UNKNOWN的未知状态</li><li>在状态回查的方法中去查询订单的支付状态</li><li>我们只需要配置RocketMQ中的事务消息回查次数(默认15次)和事务回查间隔时间(messageDelayLevel)</li></ul></li><li>事务消息机制的作用<ul><li>保证的是订单系统下单和发消息这两个事件的事务一致性</li><li>而对下游服务的事务并没有保证</li></ul></li></ul></li><li>RocketMQ配置同步刷盘+Dledger主从架构保证MQ主从同步时不会丢消息<ul><li>同步刷盘</li><li>Dledger的文件同步：基于Raft协议<ul><li><img src="/static/IT/RocketMQ/RocketMQ-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-3.png" alt="Dledger的文件同步"></li><li>Dledger会通过两阶段提交的方式保证文件在主从之间成功同步<ul><li>uncommitted阶段<ul><li>Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态</li><li>然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件</li><li>接着Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger</li></ul></li><li>commited阶段<ul><li>如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态</li><li>再接下来， Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer</li><li>让他们把消息也标记为committed状态</li></ul></li></ul></li></ul></li></ul></li><li>消费者端不要使用异步消费机制<ul><li>正常情况下，消费者端都是需要先处理本地事务，然后再给MQ一个ACK响应，这时MQ就会修改Offset，将消息标记为已消费，从而不再往其他消费者推送消息</li><li>所以在Broker的这种重新推送机制下，消息是不会在传输过程中丢失的</li><li>但是如果在开启异步消费线程后，直接返回 <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code><ul><li>那么一旦消费失败，这个消息就丢失了</li></ul></li></ul></li><li>RocketMQ特有的问题，NameServer挂了如何保证消息不丢失<ul><li>NameServer在RocketMQ中，是扮演的一个路由中心的角色，提供到Broker的路由功能</li><li>集群中任意多的节点挂掉，都不会影响他提供的路由功能</li><li>如果集群中所有的NameServer节点都挂了，生产者和消费者立即就无法工作了<ul><li>RocketMQ相当于整个服务都不可用了，那他本身肯定无法给我们保证消息不丢失了</li></ul></li><li>降级方案<ul><li>可以暂存到其他地方，然后起一个线程定时的扫描这些失败的订单消息，尝试往RocketMQ发送</li></ul></li></ul></li><li>这整套的消息零丢失方案，在各个环节都大量的降低了系统的处理性能以及吞吐量<ul><li>要根据实际的业务情况来考虑</li><li>在有些对消息可靠性要求没有那么高的场景<ul><li>在生产者端就可以采用其他一些更简单的方案来提升吞吐</li><li>而采用定时对账、补偿的机制来提高消息的可靠性</li></ul></li></ul></li></ul><hr><h2 id="消息顺序">消息顺序</h2><ul><li>全局有序：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费<ul><li>通常意义下，全局有序都可以压缩成局部有序的问题</li></ul></li><li>局部有序：只保证一部分关键消息的消费顺序<ul><li>在大部分的MQ业务场景，我们只需要能够保证局部有序就可以了</li></ul></li><li>通常情况下，发送者发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀的分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息<ul><li>MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的<ul><li>通常所谓的保证Topic全局消息有序的方式，就是将Topic配置成只有一个MessageQueue队列(默认是4个)</li><li>对整个Topic的消息吞吐影响是非常大的，如果这样用，基本上就没有用MQ的必要了</li></ul></li><li>而对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序<ul><li>RocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里</li></ul></li></ul></li></ul><hr><h2 id="消息积压">消息积压</h2><ul><li>如何确定RocketMQ有大量的消息积压<ul><li>在正常情况下，使用MQ都会要尽量保证他的消息生产速度和消费速度整体上是平衡的</li><li>但是如果部分消费者系统出现故障，就会造成大量的消息积累</li><li>使用web控制台，就能直接看到消息的积压情况</li><li>也可以通过mqadmin指令在后台检查各个Topic的消息延迟情况</li><li>RocketMQ也会在他的 ${storePathRootDir}/config目录下落地一系列的json文件，也可以用来跟踪消息积压情况</li></ul></li><li>如何处理大量积压的消息<ul><li>如果Topic下的MessageQueue配置得是足够多的，那每个Consumer实际上会分配多个MessageQueue来进行消费<ul><li>可以简单的通过增加Consumer的服务节点数量来加快消息的消费，等积压消息消费完了，再恢复成正常情况</li><li>最极限的情况是把Consumer的节点个数设置成跟MessageQueue的个数相同<ul><li>再继续增加Consumer的服务节点就没有用了</li></ul></li></ul></li><li>如果Topic下的MessageQueue配置得不够多的话：可以创建一个新的Topic，配置足够多的MessageQueue<ul><li>然后把所有消费者节点的目标Topic转向新的Topic，并紧急上线一组新的消费者，只负责消费旧Topic中的消息，并转储到新的Topic中，这个速度是可以很快的</li><li>然后在新的Topic上，就可以通过增加消费者个数来提高消费速度了。之后再根据情况恢复成正常情况</li></ul></li></ul></li><li>如果RocketMQ原本是采用的普通方式搭建主从架构，而现在想要中途改为使用Dledger高可用集群<ul><li>这时候如果不想历史消息丢失，就需要先将消息进行对齐，也就是要消费者把所有的消息都消费完，再来切换主从架构</li><li>因为Dledger集群会接管RocketMQ原有的CommitLog日志，所以切换主从架构时，如果有消息没有消费完，这些消息是存在旧的CommitLog中的，就无法再进行消费了<ul><li>这个场景下也是需要尽快的处理掉积压的消息</li></ul></li></ul></li></ul><hr><h2 id="消息轨迹">消息轨迹</h2><ul><li><code>broker.conf -&gt; traceTopicEnable=true</code></li><li>消息轨迹数据存储<ul><li>默认情况下，消息轨迹数据是存于一个系统级别的 Topic (RMQ_SYS_TRACE_TOPIC)<ul><li>这个Topic在Broker节点启动时，会自动创建出来</li><li>也支持客户端自定义轨迹数据存储的 Topic</li></ul></li></ul></li><li>在客户端的两个核心对象 DefaultMQProducer 和 DefaultMQPushConsumer 的构造函数中，都有两个可选的参数来打开消息轨迹存储<ul><li>enableMsgTrace：是否打开消息轨迹。默认是false</li><li>customizedTraceTopic：配置将消息轨迹数据存储到用户指定的Topic</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;消息零丢失&lt;/li&gt;
&lt;li&gt;消息顺序&lt;/li&gt;
&lt;li&gt;消息积压&lt;/li&gt;
&lt;li&gt;消息轨迹&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;消息零丢失&quot;&gt;消息零丢失&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;哪些环节会有丢消息的可能
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://jxch.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>JVM-JIT</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-jit/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-jit/</id>
    <published>2024-09-09T01:59:00.000Z</published>
    <updated>2024-09-09T02:01:07.561Z</updated>
    
    <content type="html"><![CDATA[<ul><li>解释执行：Java程序在运行的时候，主要就是执行字节码指令，一般这些指令会按照顺序解释执行，这种<br>就是解释执行</li><li>JIT （即时编译器 Just&nbsp;In&nbsp;Time&nbsp;Compiler）：那些被频繁调用的代码（热点代码）如果按照解释执行，效率非常低<ul><li>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化</li><li><img src="/static/IT/JVM/JVM-JIT-1.png" alt=""></li><li><img src="/static/IT/JVM/JVM-JIT-2.png" alt=""><ul><li>C1编译器（几乎不会对代码进行优化）：是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序</li><li>C2编译器：是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序<ul><li>但是C2代码已超级复杂，无人能维护！所以才会开发Java编写的Graal编译器取代C2 (JDK10开始)</li></ul></li><li>分层编译：综合了&nbsp;C1&nbsp;的启动性能优势和&nbsp;C2&nbsp;的峰值性能优势<ul><li>使用 “-Xint” 参数强制虚拟机运行于只有解释器的编译模式</li><li>使用 “-Xcomp” 强制虚拟机运行于只有&nbsp;JIT&nbsp;的编译模式下</li></ul></li></ul></li></ul></li><li>JVM&nbsp;的执行状态分为了&nbsp;5&nbsp;个层次<ul><li>第&nbsp;0&nbsp;层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译</li><li>第&nbsp;1&nbsp;层：可称为&nbsp;C1&nbsp;编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启&nbsp;Profiling</li><li>第&nbsp;2&nbsp;层：也称为&nbsp;C1&nbsp;编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数&nbsp;profiling&nbsp;的&nbsp;C1&nbsp;编译</li><li>第&nbsp;3&nbsp;层：也称为&nbsp;C1&nbsp;编译，执行所有带&nbsp;Profiling&nbsp;的&nbsp;C1&nbsp;编译</li><li>第&nbsp;4&nbsp;层：可称为&nbsp;C2&nbsp;编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化</li></ul></li><li><code>java&nbsp;-XX:+PrintFlagsFinal&nbsp;–version</code> 查询JVM参数值</li><li>热点代码：那些被频繁调用的代码<ul><li>这些再次编译后的机器码会被缓存起来，以备下次使用</li><li><code>-XX:ReservedCodeCacheSize</code> JIT&nbsp;编译后的代码都会放在&nbsp;CodeCache&nbsp;里，如果这个空间不足，JIT&nbsp;就无法继续编译，编译执行会变成解释执行，性能会降低一个数量级，同时，JIT&nbsp;编译器会一直尝试去优化代码，从而造成了&nbsp;CPU&nbsp;占用上升</li></ul></li><li>热点探测（基于计数器）：方法调用计数器（Invocation&nbsp;Counter）和回边计数器 （Back&nbsp;Edge&nbsp;Counter）<ul><li>为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是 “热点方法”</li><li>这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发&nbsp;JIT&nbsp;编译</li><li>方法调用计数器：用于统计方法被调用的次数，方法调用计数器的默认阈值在客户端模式下是&nbsp;1500&nbsp;次，在服务端模式下是&nbsp;10000&nbsp;次（<code>java -verion</code> 查询模式，用<code>-XX:CompileThreshold</code>指定次数）</li><li>回边计数器：在字节码中遇到控制流向后跳转的指令称为“回边”（Back&nbsp;Edge）<ul><li>该值用于计算是否触发&nbsp;C1&nbsp;编译的阈值，在不开启分层编译的情况下，在服务端模式下是10700</li><li>回边计数器阈值&nbsp;=方法调用计数器阈值（CompileThreshold）×（OSR比率（OnStackReplacePercentage）-解释器监控比率（InterpreterProfilePercentage））/100<ul><li>回边计数器阈值&nbsp;=10000 ×（140-33）=10700</li><li>通过&nbsp;-XX:CompileThreshold&nbsp;来设置热点方法的阈值</li></ul></li></ul></li></ul></li><li>编译优化技术：通过一些例行检查优化，可以智能地编译出运行时的最优性能代码<ul><li>方法内联：把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用，JVM&nbsp;会自动识别热点方法，并对它们使用方法内联进行优化<ul><li>方法体太大了：JVM&nbsp;将不执行内联操作</li><li>经常执行的方法：方法体大小小于&nbsp;325&nbsp;字节的都会进行内联，通过&nbsp;<code>-XX:FreqInlineSize=N</code>&nbsp;来设置大小值</li><li>不是经常执行的方法：方法大小小于&nbsp;35&nbsp;字节才会进行内联，通过&nbsp;<code>-XX:MaxInlineSize=N</code>&nbsp;来重置大小值</li><li>可以通过以下几种方式来提高方法内联<ul><li>通过设置&nbsp;JVM&nbsp;参数来减小热点阈值或增加方法体阈值，但这种方法意味着需要占用更多地内存</li><li>避免在一个方法中写大量代码，习惯使用小方法体</li><li>尽量使用&nbsp;final、private、static&nbsp;关键字修饰方法，编码方法因为继承，会需要额外的类型检查</li></ul></li></ul></li><li>锁消除：<code>-XX:+EliminateLocks</code><ul><li>在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候&nbsp;JIT&nbsp;编译会对这个对象的方法锁进行锁消除</li></ul></li><li>标量替换：前提是需要开启逃逸分析 <code>-XX:+EliminateAllocations</code><ul><li>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替</li><li>将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了</li></ul></li><li>逃逸分析：<code>-XX:+DoEscapeAnalysis</code> 分析对象动态作用域，当一个对象在方法中定义后，它可能被外部方法引用<ul><li>从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度</li><li>如果确定一个对象不会逃逸出线程之外，那么让对象在栈上分配内存可以提高JVM的效率</li><li>必须要符合热点代码，JIT才会优化</li><li><img src="/static/IT/JVM/JVM-JIT-3.png" alt="逃逸分析"></li><li>如果逃逸分析出来的对象可以在栈上分配，那么该对象的生命周期就跟随线程了，就不需要垃圾回收</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;解释执行：Java程序在运行的时候，主要就是执行字节码指令，一般这些指令会按照顺序解释执行，这种&lt;br&gt;
就是解释执行&lt;/li&gt;
&lt;li&gt;JIT （即时编译器 Just&amp;nbsp;In&amp;nbsp;Time&amp;nbsp;Compiler）：那些被频繁调用的代码（热点</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC-ZGC</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc-zgc/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc-zgc/</id>
    <published>2024-09-09T01:47:00.000Z</published>
    <updated>2024-09-09T01:55:43.147Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ZGC中的内存布局</li><li>ZGC流程</li><li>ZGC参数设置</li></ul><hr><h2 id="ZGC中的内存布局">ZGC中的内存布局</h2><ul><li>ZGC 设计目标：ZGC（The&nbsp;Z&nbsp;Garbage&nbsp;Collector）是JDK&nbsp;11中推出的一款追求极致低延迟的垃圾收集器<ul><li>停顿时间不超过10ms（JDK16已经达到不超过1ms）</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加</li><li>支持8MB~4TB级别的堆，JDK15后已经可以支持16TB</li></ul></li><li>ZGC中的内存布局<ul><li>为了细粒度地控制内存的分配，和G1一样，ZGC将内存划分成小的分区，在ZGC中称为页面（page）</li><li>ZGC中没有分代的概念（新生代、老年代）</li><li>ZGC支持3种页面，分别为小页面、中页面和大页面</li><li>小页面指的是2MB的页面空间，中页面指32MB的页面空间，大页面指受操作系统控制的大页</li><li><img src="/static/IT/JVM/JVM-GC-ZGC-1.png" alt="ZGC 内存布局"><ul><li>当对象大小小于等于256KB时，对象分配在小页面</li><li>当对象大小在256KB和4M之间，对象分配在中页面</li><li>当对象大于4M，对象分配在大页面</li></ul></li><li>回收策略：小页面优先回收；中页面和大页面则尽量不回收</li><li>为什么这么设计<ul><li>标准大页（huge&nbsp;page）是Linux&nbsp;Kernel&nbsp;2.6引入的，目的是通过使用大页内存来取代传统的4KB内存页面，以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能</li><li>Huge&nbsp;pages&nbsp;有两种格式大小：&nbsp;2MB&nbsp;和&nbsp;1GB&nbsp;，&nbsp;2MB&nbsp;页块大小适合用于&nbsp;GB&nbsp;大小的内存，&nbsp;1GB&nbsp;页块大小适合用于&nbsp;TB&nbsp;级别的内存；&nbsp;2MB&nbsp;是默认的页大小</li></ul></li></ul></li><li>ZGC支持NUMA<ul><li><img src="/static/IT/JVM/JVM-GC-ZGC-2.png" alt="NUMA"><ul><li>在过去，对于X86架构的计算机，内存控制器还没有整合进CPU，所有对内存的访问都需要通过北桥芯片来完 成。X86系统中的所有内存都可以通过CPU进行同等访问。任何CPU访问任何内存的速度是一致的，不必考虑不同内存地址之间的差异，这称为“统一内存访问”（Uniform&nbsp;Memory&nbsp;Access，UMA）</li><li>在UMA中，各处理器与内存单元通过互联总线进行连接，各个CPU之间没有主从关系</li><li>之后的X86平台经历了一场从“拼频率”到“拼核心数”的转变，越来越多的核心被尽可能地塞进了同一块芯片上，各个核心对于内存带宽的争抢访问成为瓶颈，所以人们希望能够把CPU和内存集成在一个单元上（称Socket），这就是非统一内存访问（Non-Uniform&nbsp;Memory&nbsp;Access，NUMA）。很明显，在NUMA下，CPU访问本地存储器的速度比访问非本地存储器快一些</li></ul></li><li><img src="/static/IT/JVM/JVM-GC-ZGC-3.png" alt="NUMA"><ul><li>ZGC是支持NUMA的，在进行小页面分配时会优先从本地内存分配，当不能分配时才会从远端的内存分配</li><li>对于中页面和大页面的分配，ZGC并没有要求从本地内存分配，而是直接交给操作系统，由操作系统找到一块能满足ZGC页面的空间</li><li>对于小页面，存放的都是小对象，从本地内存分配速度很快，且不会造成内存使用的不平衡，而中页面和大页面因为需要的空间大，如果也优先从本地内存分配，极易造成内存使用不均衡，反而影响性能</li></ul></li></ul></li></ul><hr><h2 id="ZGC流程">ZGC流程</h2><ul><li>指针着色技术（Color&nbsp;Pointers）：他在指针中借了几个位出来做事情，所以它必须要求在64位的机器上才可以工作。并且因为要求64位的指针，也就不能支持压缩指针<ul><li><img src="/static/IT/JVM/JVM-GC-ZGC-4.png" alt="指针着色"></li><li>ZGC中低42位表示使用中的堆空间</li><li>ZGC借几位高位来做GC相关的事情 (快速实现垃圾回收中的并发标记、转移和重定位等)</li></ul></li><li>根可达算法：来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC&nbsp;Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference&nbsp;Chain），当一个对象到GC&nbsp;Roots没有任何引用链相连时，则证明此对象是不可用的<ul><li><img src="/static/IT/JVM/JVM-GC-ZGC-5.png" alt="根可达"></li><li>作为GC&nbsp;Roots的对象主要包括下面4种<ul><li>虚拟机栈（栈帧中的本地变量表）：各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>方法区中类静态变量：java类的引用类型静态变量。</li><li>方法区中常量：比如：字符串常量池里的引用。</li><li>本地方法栈中JNI指针：（即一般说的 Native方法）</li></ul></li></ul></li><li>一次ZGC流程<ul><li><img src="/static/IT/JVM/JVM-GC-ZGC-6.png" alt="ZGC GC"><ul><li>标记阶段 (标识垃圾)<ul><li>初始标记（有STW）：从根集合(GC&nbsp;Roots)出发，找出根集合直接引用的活跃对象(根对象)<ul><li>初始标记只需要扫描所有GC&nbsp;Roots，其处理时间和GC&nbsp;Roots的数量成正比，停顿时间不会随着堆的大小或者活跃对象的大小而增加</li></ul></li><li>并发标记（无STW）：根据初始标记找到的根对象，使用深度优先遍历对象的成员变量进行标记<ul><li>扫描剩余的所有对象，这个处理时间比较长，所以走并发，业务线程与GC线程同时运行，但是这个阶段会产生漏标问题</li></ul></li><li>再标记（有STW）：主要处理漏标对象，通过SATB算法解决（G1中的解决漏标的方案）</li></ul></li><li>转移阶段 (对象复制或移动)：基于指针着色的并发转移算法<ul><li>并发转移准备（无STW&nbsp;）：分析最有价值GC分页</li><li>初始转移（有STW）：转移初始标记的存活对象同时做对象重定位</li><li>并发转移（无STW）：对转移并发标记的存活对象做转移（转发表）<ul><li>对象转移和插转发表做原子操作</li><li><img src="/static/IT/JVM/JVM-GC-ZGC-7.png" alt=""></li><li><img src="/static/IT/JVM/JVM-GC-ZGC-8.png" alt=""></li></ul></li></ul></li><li>下次GC中的并发标记（同时做上次并发标记对象的重定位）：基于指针着色的重定位算法<ul><li><img src="/static/IT/JVM/JVM-GC-ZGC-9.png" alt="指针着色中 M0 和 M1 区分"></li></ul></li></ul></li></ul></li><li>ZGC中读屏障：当应用线程从堆中读取对象引用时，就会执行这段代码（仅“从堆中读取对象引用”）<ul><li>涉及对象：并发转移但还没做对象重定位的对象（着色指针使用M0和M1可以区分）</li><li>触发时机：在两次GC之间业务线程访问这样的对象</li><li>触发操作：对象重定位+删除转发表记录（两个一起做原子操作）</li><li><img src="/static/IT/JVM/JVM-GC-ZGC-10.png" alt="读屏障"></li></ul></li><li>ZGC中GC触发机制（JAVA16）<ul><li>预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”<ul><li>JVM启动预热，如果从来没有发生过GC，则在堆内存使用超过10%、20%、30%时，分别触发一次GC，以收集GC数据</li></ul></li><li>基于分配速率的自适应算法：最主要的GC触发方式（默认方式），其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”<ul><li>通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。日志中关键字是“Allocation&nbsp;Rate”</li></ul></li><li>基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景</li><li>主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，如果我们的服务已经加了基于固定时间间隔的触发机制，可以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性</li><li>阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation&nbsp;Stall”</li><li>外部触发：代码中显式调用System.gc()触发。&nbsp;日志中关键字是“System.gc()”</li><li>元数据分配触发：元数据区不足时导致，一般不需要关注。&nbsp;日志中关键字是“Metadata&nbsp;GC&nbsp;Threshold”</li></ul></li></ul><hr><h2 id="ZGC参数设置">ZGC参数设置</h2><ul><li>ZGC参数设置：ZGC&nbsp;优势不仅在于其超低的&nbsp;STW&nbsp;停顿，也在于其参数的简单，绝大部分生产场景都可以自适应<ul><li>堆大小：Xmx。当分配速率过高，超过回收速率，造成堆内存不够时，会触发&nbsp;Allocation&nbsp;Stall，这类&nbsp;Stall&nbsp;会减缓当前的用户线程。因此，当我们在&nbsp;GC&nbsp;日志中看到&nbsp;Allocation&nbsp;Stall，通常可以认为堆空间偏小或者&nbsp;concurrent&nbsp;gc&nbsp;threads&nbsp;数偏小</li><li>GC&nbsp;触发时机：ZAllocationSpikeTolerance,&nbsp;ZCollectionInterval<ul><li>ZAllocationSpikeTolerance&nbsp;用来估算当前的堆内存分配速率，在当前剩余的堆内存下，ZAllocationSpikeTolerance&nbsp;越大，估算的达到 OOM&nbsp;的时间越快，ZGC&nbsp;就会更早地进行触发&nbsp;GC</li><li>ZCollectionInterval&nbsp;用来指定&nbsp;GC&nbsp;发生的间隔，以秒为单位触发&nbsp;GC</li></ul></li><li>GC&nbsp;线程：ParallelGCThreads，&nbsp;ConcGCThreads<ul><li>ParallelGCThreads&nbsp;是设置&nbsp;STW&nbsp;任务的&nbsp;GC&nbsp;线程数目，默认为&nbsp;CPU&nbsp;个数的&nbsp;60%</li><li>ConcGCThreads&nbsp;是并发阶段&nbsp;GC&nbsp;线程的数目，默认为&nbsp;CPU&nbsp;个数的12.5%</li><li>增加&nbsp;GC&nbsp;线程数目，可以加快&nbsp;GC&nbsp;完成任务，减少各个阶段的时间，但也会增加&nbsp;CPU&nbsp;的抢占开销，可根据生产情况调整</li></ul></li></ul></li><li>ZGC典型应用场景<ul><li>对于性能来说，不同的配置对性能的影响是不同的<ul><li>大堆场景下，ZGC&nbsp;在各类&nbsp;Benchmark&nbsp;中能够超过&nbsp;G1&nbsp;大约&nbsp;5%&nbsp;到&nbsp;20%</li><li>在小堆情况下，则要低于&nbsp;G1&nbsp;大约&nbsp;10%</li></ul></li><li>当前&nbsp;ZGC&nbsp;不支持压缩指针和分代&nbsp;GC，其内存占用相对于&nbsp;G1&nbsp;来说要稍大，在小堆情况下较为明显，而在大堆情况下，这些多占用的内存则显得不那么突出</li><li>以下两类应用强烈建议使用&nbsp;ZGC&nbsp;来提升业务体验<ul><li>超大堆应用。超大堆（百&nbsp;G&nbsp;以上）下，CMS&nbsp;或者&nbsp;G1&nbsp;如果发生&nbsp;Full&nbsp;GC，停顿会在分钟级别，可能会造成业务的中断，强烈推荐使用&nbsp;ZGC</li><li>当业务应用需要提供高服务级别协议（Service&nbsp;Level&nbsp;Agreement，SLA），例如&nbsp;99.99%&nbsp;的响应时间不能超过&nbsp;100ms，此类应用无论堆大小，均推荐采用低停顿的&nbsp;ZGC</li></ul></li></ul></li><li>ZGC生产注意事项<ul><li>RSS&nbsp;内存异常现象：ZGC&nbsp;采用多映射&nbsp;multi-mapping&nbsp;的方法实现了三份虚拟内存指向同一份物理内存，而&nbsp;Linux&nbsp;统计进程&nbsp;RSS&nbsp;内存占用的算法是比较脆弱的，这种多映射的方式并没有考虑完整，因此根据当前&nbsp;Linux&nbsp;采用大页和小页时，其统计的开启&nbsp;ZGC&nbsp;的&nbsp;Java&nbsp;进程的内存表现是不同的<ul><li>在内核使用小页的&nbsp;Linux&nbsp;版本上， 这种三映射的同一块物理内存会被&nbsp;linux&nbsp;的&nbsp;RSS&nbsp;占用算法统计&nbsp;3&nbsp;次，因此通常可以看到使用&nbsp;ZGC&nbsp;的&nbsp;Java&nbsp;进程 的&nbsp;RSS&nbsp;内存膨胀了三倍左右，但是实际占用只有统计数据的三分之一，会对运维或者其他业务造成一定的困 扰</li><li>在内核使用大页的&nbsp;Linux&nbsp;版本上，这部分三映射的物理内存则会统计到&nbsp;hugetlbfs&nbsp;inode&nbsp;上，而不是当 前&nbsp;Java&nbsp;进程上</li></ul></li><li>共享内存调整<ul><li>ZGC&nbsp;需要在&nbsp;share&nbsp;memory&nbsp;中建立一个内存文件来作为实际物理内存占用，因此当要使用的&nbsp;Java&nbsp;的堆大小大于&nbsp;/dev/shm&nbsp;的大小时，需要对&nbsp;/dev/shm&nbsp;的大小进行调整<ul><li>通常来说，命令如下（下面是将&nbsp;/dev/shm&nbsp;调整为&nbsp;64G）：<ul><li><code>vi/etc/fstabtmpfs&nbsp;/dev/shm&nbsp;tmpfs&nbsp;defaults,size=&nbsp;65536M00</code></li></ul></li><li>首先修改&nbsp;fstab&nbsp;中&nbsp;shm&nbsp;配置的大小，size&nbsp;的值根据需求进行修改，然后再进行&nbsp;shm&nbsp;的&nbsp;mount&nbsp;和&nbsp;umount<ul><li><code>umount/dev/shmmount&nbsp;/dev/shm</code></li></ul></li></ul></li></ul></li><li>mmap&nbsp;节点上限调整<ul><li>ZGC&nbsp;的堆申请和传统的&nbsp;GC&nbsp;有所不同，需要占用的&nbsp;memory&nbsp;mapping&nbsp;数目更多，即每个&nbsp;ZPage&nbsp;需要&nbsp;mmap&nbsp;映射三次，这样系统中仅&nbsp;Java&nbsp;Heap&nbsp;所占用的&nbsp;mmap&nbsp;个数为&nbsp;<code>(Xmx&nbsp;/&nbsp;zpage_size)&nbsp;*&nbsp;3</code>，默认情况下&nbsp;zpage_size&nbsp;的大小为&nbsp;2M</li><li>为了给&nbsp;JNI&nbsp;等&nbsp;native&nbsp;模块中的&nbsp;mmap&nbsp;映射数目留出空间，内存映射的数目应该调整为&nbsp;<code>(Xmx&nbsp;/&nbsp;zpage_size)&nbsp;3*1.2</code></li><li>默认的系统&nbsp;memory&nbsp;mapping&nbsp;数目由文件&nbsp;<code>/proc/sys/vm/max_map_count</code>&nbsp;指定，通常数目为&nbsp;65536，当给&nbsp;JVM&nbsp;配置一个很大的堆时，需要调整该文件的配置，使得其大于<code>&nbsp;(Xmx&nbsp;/&nbsp;zpage_size)&nbsp;3*1.2</code>。</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;ZGC中的内存布局&lt;/li&gt;
&lt;li&gt;ZGC流程&lt;/li&gt;
&lt;li&gt;ZGC参数设置&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;ZGC中的内存布局&quot;&gt;ZGC中的内存布局&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ZGC 设计目标：ZGC（The&amp;nbsp;Z&amp;nbsp;G</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC-G1&amp;ZGC</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc-g1-zgc/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc-g1-zgc/</id>
    <published>2024-09-09T01:37:00.000Z</published>
    <updated>2024-09-09T01:44:28.680Z</updated>
    
    <content type="html"><![CDATA[<ul><li>G1</li><li>ZGC</li><li>如何选择垃圾收集器</li><li>安全点与安全区域</li></ul><hr><h2 id="G1">G1</h2><ul><li>特点<ul><li>面向服务器的垃圾收集器，针对多核处理器及大容量内存的机器</li><li>以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征</li></ul></li><li>内存划分<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-1.png" alt="G1 内存划分"></li><li>G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region</li><li>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M（<code>-XX:G1HeapRegionSize</code>）</li><li>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是Region的集合（可以不连续）</li><li>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过<code>-XX:G1NewSizePercent</code>设置新生代初始占比<ul><li>在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过<code>-XX:G1MaxNewSizePercent</code>调整</li><li>年轻代中的Eden和Survivor对应的region也跟之前一样，默认 8:1:1</li></ul></li><li>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化</li><li>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理<ul><li>G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中</li><li>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，而且一个大对象如果太大，可能会横跨多个Region来存放</li><li>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销</li></ul></li><li>Full&nbsp;GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收</li></ul></li><li>G1收集器一次GC的运作过程大致分为以下几个步骤<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-2.png" alt="G1 GC"></li><li>初始标记（initial&nbsp;mark，STW）：暂停所有的其他线程，并记录下gc&nbsp;roots直接能引用的对象，速度很快</li><li>并发标记（Concurrent&nbsp;Marking）：同CMS的并发标记</li><li>最终标记（Remark，STW）：同CMS的重新标记</li><li>筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间 (可以用JVM参数&nbsp;<code>-XX:MaxGCPauseMillis</code> 指定) 来制定回收计划，尽量把GC导致的停顿时间控制在我们指定的范围内<ul><li>这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率<ul><li>CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本</li></ul></li><li>不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</li><li>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region (这也就是它的名字Garbage-First的由来)</li></ul></li></ul></li><li>具备以下特点<ul><li>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行</li><li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念</li><li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1&nbsp;和&nbsp;CMS&nbsp;共同的关注点，但G1&nbsp;除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段 (<code>-XX:MaxGCPauseMillis</code>) 内完成垃圾收集<ul><li>默认的停顿目标为两百毫秒</li><li>如果我们把停顿时间调得非常低，&nbsp;很可能出现的结果就是由于停顿目标时间太短，&nbsp;导致每次选出来的回收集只占堆内存很小的一部分，&nbsp;收集器收集的速度逐渐跟不上分配器分配的速度，&nbsp;导致垃圾慢慢堆积，&nbsp;最终占满堆引发 Full&nbsp;GC 反而降低性能（单线程）</li></ul></li></ul></li><li>G1垃圾收集分类<ul><li>YoungGC 并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数&nbsp;-XX:MaxGCPauseMills&nbsp;设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young&nbsp;GC，直到下一次Eden区放满，G1计算回收时间接近参数&nbsp;-XX:MaxGCPauseMills&nbsp;设定的值，那么就会触发Young&nbsp;GC</li><li>MixedGC 不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full&nbsp;GC</li><li>Full&nbsp;GC 停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的 (Shenandoah优化成多线程收集了)</li></ul></li><li>G1收集器参数设置<ul><li>-XX:+UseG1GC: 使用G1收集器</li><li>-XX:ParallelGCThreads: 指定GC工作的线程数量</li><li>-XX:G1HeapRegionSize: 指定分区大小 (1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</li><li>-XX:MaxGCPauseMillis: 目标暂停时间 (默认200ms)</li><li>-XX:G1NewSizePercent: 新生代内存初始空间 (默认整堆5%)</li><li>-XX:G1MaxNewSizePercent: 新生代内存最大空间</li><li>-XX:TargetSurvivorRatio: Survivor区的填充容量 (默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</li><li>-XX:MaxTenuringThreshold: 最大年龄阈值(默认15)</li><li>-XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值 (默认45%)，则执行新生代和老年代的混合收集(MixedGC)</li><li>-XX:G1MixedGCLiveThresholdPercent (默认85%)&nbsp;&nbsp;region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</li><li>-XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收 (默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长</li><li>-XX:G1HeapWastePercent (默认5%):&nbsp;gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了</li></ul></li><li>G1垃圾收集器优化：<code>-XX:MaxGCPauseMills</code> 在保证年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed&nbsp;gc<ul><li>假设参数&nbsp;-XX:MaxGCPauseMills&nbsp;设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代 gc，那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中</li><li>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中</li></ul></li><li>什么场景适合使用G1<ul><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过1秒</li><li>8GB以上的堆内存 (建议值)</li><li>停顿时间是500ms以内</li></ul></li><li>每秒几十万并发的系统：新生代设置的过大，会导致 young&nbsp;gc 卡顿，这种情况下用G1，设置&nbsp;-XX:MaxGCPauseMills&nbsp;为50ms，用户几乎无感知</li></ul><hr><h2 id="ZGC">ZGC</h2><ul><li>目标：以低延迟为首要目标<ul><li>支持TB量级的堆</li><li>最大GC停顿时间不超10ms：停顿时间不会随着堆的增大而增长</li><li>奠定未来GC特性的基础</li><li>最糟糕的情况下吞吐量会降低15%</li></ul></li><li>不分代 (暂时)</li><li>ZGC 内存布局：基于Region内存布局<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-3.png" alt="ZGC 内存布局"></li><li>使用了读屏障、&nbsp;颜色指针等技术来实现可并发的标记-整理算法</li><li>ZGC的Region可以具有大、&nbsp;中、&nbsp;小三类容量<ul><li>小型Region（Small&nbsp;Region）&nbsp;：&nbsp;容量固定为2MB，&nbsp;用于放置小于256KB的小对象</li><li>中型Region（Medium&nbsp;Region）&nbsp;：&nbsp;容量固定为32MB，&nbsp;用于放置大于等于256KB但小于4MB的对象</li><li>大型Region（Large&nbsp;Region）&nbsp;：&nbsp;容量不固定，&nbsp;可以动态变化，&nbsp;但必须为2MB的整数倍，&nbsp;用于放置4MB或以上的大对象<ul><li>每个大型Region中只会存放一个大对象，&nbsp;这也预示着虽然名字叫作“大型Region”，&nbsp;但它的实际容量完全有可能小于中型Region，&nbsp;最小容量可低至4MB</li><li>大型Region在ZGC的实现中是不会被重分配的（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段）&nbsp;，&nbsp;因为复制一个大对象的代价非常高昂</li></ul></li></ul></li></ul></li><li>NUMA-aware<ul><li>NUMA对应的有UMA，UMA即Uniform&nbsp;Memory&nbsp;Access&nbsp;Architecture，NUMA 就是Non&nbsp;Uniform&nbsp;Memory&nbsp;Access&nbsp;Architecture</li><li>UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题（争夺内存总线访问权），有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈</li><li>NUMA的话每个CPU对应有一块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-4.png" alt="NUMA"></li></ul></li><li>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。ZGC 是能自动感知NUMA架构并充分利用NUMA架构特性的</li></ul></li><li>颜色指针（Colored&nbsp;Pointers）：以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-5.png" alt="颜色指针"></li><li>每个对象有一个64位指针，这64位被分为<ul><li>18位：预留给以后使用</li><li>1位：Finalizable 标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问</li><li>1位：Remapped 标识，设置此位的值后，对象未指向relocation&nbsp;set中（relocation&nbsp;set表示需要GC的Region集合）</li><li>1位：Marked1 标识</li><li>1位：Marked0 标识，和上面的Marked1都是标记对象用于辅助GC</li><li>42位：对象的地址（所以它可以支持 2^42=4T 内存）<ul><li>既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的<ul><li>不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T</li></ul></li></ul></li></ul></li><li>为什么有2个mark标记<ul><li>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记<ul><li>GC周期1：使用mark0,&nbsp;则周期结束所有引用mark标记都会成为01</li><li>GC周期2：使用mark1,&nbsp;则期待的mark标记10，所有引用都能被重新标记</li></ul></li></ul></li><li>对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了（CompressedOops，压缩指针也是32位）</li><li>颜色指针的三大优势<ul><li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集</li><li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障</li><li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能</li></ul></li></ul></li><li>读屏障：之前的GC都是采用Write&nbsp;Barrier，这次ZGC采用了完全不同的方案读屏障<ul><li>在标记和移动对象的阶段，每次「从堆里对象的引用类型中读取一个指针」的时候，都需要加上一个Load&nbsp;Barriers<ul><li>尝试读取堆中的一个对象引用</li><li>如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障<ul><li>如何判断对象被移动过：颜色指针<ul><li>如果指针是Bad&nbsp;Color，那么程序还不能往下执行，需要「slow&nbsp;path」，修正指针</li><li>如果指针是Good&nbsp;Color，那么正常往下执行</li></ul></li><li>判断对象是Bad&nbsp;Color还是Good&nbsp;Color的依据是什么：Colored&nbsp;Pointers 的 4个颜色位<ul><li>当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是 Bad/Good&nbsp;Color了</li></ul></li></ul></li><li>屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里</li></ul></li><li>这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW</li><li>正是因为Load&nbsp;Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销</li></ul></li><li>ZGC 运作过程<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-6.png" alt="ZGC GC"></li><li>并发标记（Concurrent&nbsp;Mark）<ul><li>与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记 (Mark&nbsp;Start)和最终标记(Mark&nbsp;End)也会出现短暂的停顿</li><li>与G1不同的是，&nbsp;ZGC的标记是在指针上而不是在对象上进行的，&nbsp;标记阶段会更新染色指针中的Marked&nbsp;0、&nbsp;Marked&nbsp;1标志位</li></ul></li><li>并发预备重分配（Concurrent&nbsp;Prepare&nbsp;for&nbsp;Relocate）<ul><li>这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation&nbsp;Set）</li><li>ZGC每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本</li></ul></li><li>并发重分配（Concurrent&nbsp;Relocate）<ul><li>重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward&nbsp;Table），记录从旧对象到新对象的转向关系</li><li>ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力</li></ul></li><li>并发重映射（Concurrent&nbsp;Remap）<ul><li>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切</li><li>ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销</li><li>一旦所有指针都被修正之后，&nbsp;原来记录新旧对象关系的转发表就可以释放掉了</li></ul></li></ul></li><li>ZGC 存在的问题：浮动垃圾<ul><li>ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的</li><li>假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾</li><li>解决方案<ul><li>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案</li><li>如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集</li></ul></li></ul></li><li>ZGC 参数设置：<code>-XX:+UnlockExperimentalVMOptions&nbsp;「-XX:+UseZGC」</code><ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-7.png" alt="ZGC 参数设置"></li></ul></li><li>ZGC 触发时机<ul><li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置</li><li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要是统计GC时间，为其他GC机制使用</li><li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间&nbsp;-&nbsp;一次GC最大持续时间&nbsp;-&nbsp;一次GC检测周期时间）</li><li>主动触发，（默认开启，可通过ZProactive参数配置）&nbsp;距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49&nbsp;*&nbsp;一次GC的最大持续时间），超过则触发</li></ul></li></ul><hr><h2 id="如何选择垃圾收集器">如何选择垃圾收集器</h2><ul><li>如何选择垃圾收集器<ul><li><img src="/static/IT/JVM/JVM-GC-G1-ZGC-8.png" alt="垃圾收集器"><ul><li>JDK&nbsp;1.8默认使用&nbsp;Parallel(年轻代和老年代都是)</li><li>JDK&nbsp;1.9默认使用&nbsp;G1&nbsp;<br>1.&nbsp;优先调整堆的大小让服务器自己来选择<br>2.&nbsp;如果内存小于100M，使用串行收集器<br>3.&nbsp;如果是单核，并且没有停顿时间的要求，串行或JVM自己选择<br>4.&nbsp;如果允许停顿时间超过1秒，选择并行或者JVM自己选<br>5.&nbsp;如果响应时间最重要，并且不能超过1秒，使用并发收集器<br>6.&nbsp;4G以下可以用 parallel，4-8G 可以用 ParNew+CMS，8G 以上可以用 G1，几百G以上用 ZGC</li></ul></li></ul></li></ul><h2 id="安全点-安全区域">安全点 &amp; 安全区域</h2><ul><li>安全点<ul><li>安全点就是指代码中一些特定的位置，当线程运行到这些位置时它的状态是确定的，这样JVM就可以安全的进行一些操作，比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发<ul><li>方法返回之前</li><li>调用某个方法之后</li><li>抛出异常的位置</li><li>循环的末尾</li></ul></li><li>大体实现思想是当垃圾收集需要中断线程的时候，&nbsp;不直接对线程操作，&nbsp;仅仅简单地设置一个标志位，&nbsp;各个线程执行过程时会不停地主动去轮询这个标志，&nbsp;一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。&nbsp;轮询标志的地方和安全点是重合的<ul><li>这么说不准确，利用的是将内存块设为不可写，相关线程去写的时候会失败触发single机制进入安全点等待GC</li></ul></li></ul></li><li>安全区域：Safe&nbsp;Region&nbsp;是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始&nbsp;GC&nbsp;都是安全的<ul><li>Safe&nbsp;Point&nbsp;是对正在执行的线程设定的，如果一个线程处于&nbsp;Sleep&nbsp;或中断状态，它就不能响应&nbsp;JVM&nbsp;的中断请求，再运行到&nbsp;Safe&nbsp;Point&nbsp;上，因此&nbsp;JVM&nbsp;引入了&nbsp;Safe&nbsp;Region</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;G1&lt;/li&gt;
&lt;li&gt;ZGC&lt;/li&gt;
&lt;li&gt;如何选择垃圾收集器&lt;/li&gt;
&lt;li&gt;安全点与安全区域&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;G1&quot;&gt;G1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;面向服务器的垃圾收集器，针对多核处理器及大</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-gc/</id>
    <published>2024-09-09T01:22:00.000Z</published>
    <updated>2024-09-09T01:33:03.268Z</updated>
    
    <content type="html"><![CDATA[<ul><li>垃圾收集算法</li><li>垃圾收集器</li><li>CMS 调优</li><li>三色标记</li><li>记忆集与卡表</li></ul><hr><h2 id="垃圾收集算法">垃圾收集算法</h2><p><img src="/static/IT/JVM/JVM-GC-1.png" alt="垃圾收集算法"></p><ul><li>分代收集理论：将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法<ul><li>在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集</li><li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上</li></ul></li><li>标记-复制算法：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收<ul><li><img src="/static/IT/JVM/JVM-GC-2.png" alt="标记-复制算法"></li></ul></li><li>标记-清除算法：算法分为“标记”和“清除”阶段：标记存活的对象，&nbsp;统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象&nbsp;。它是最基础的收集算法，比较简单，但是会带来两个明显的问题<ul><li>效率问题&nbsp;&nbsp;(如果需要标记的对象太多，效率不高)</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li><li><img src="/static/IT/JVM/JVM-GC-3.png" alt="标记-清除算法"></li></ul></li><li>标记-整理算法：根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存<ul><li><img src="/static/IT/JVM/JVM-GC-4.png" alt="标记-整理算法"></li></ul></li></ul><hr><h2 id="垃圾收集器">垃圾收集器</h2><p><img src="/static/IT/JVM/JVM-GC-5.png" alt="垃圾收集器"></p><ul><li>Serial 收集器 (-XX:+UseSerialGC&nbsp;&nbsp;-XX:+UseSerialOldGC)<ul><li>新生代采用复制算法，老年代采用标记-整理算法</li><li>单线程：在进行垃圾收集工作的时候必须暂停其他所有的工作线程（&nbsp;“Stop&nbsp;The&nbsp;World”&nbsp;），直到它收集结束</li><li><img src="/static/IT/JVM/JVM-GC-6.png" alt="Serial"></li><li>Serial&nbsp;Old 收集器是 Serial 收集器的老年代版本<ul><li>还可以与 Parallel&nbsp;Scavenge 收集器搭配使用</li><li>作为 CMS 收集器的后备方案</li></ul></li></ul></li><li>Parallel&nbsp;Scavenge 收集器 (-XX:+UseParallelGC(年轻代), -XX:+UseParallelOldGC(老年代))：JDK8 默认<ul><li>新生代采用复制算法，老年代采用标记-整理算法</li><li>Serial 收集器的多线程版本（默认的收集线程数跟cpu核数相同 <code>-XX:ParallelGCThreads</code>）</li><li>Parallel&nbsp;Scavenge 收集器关注点是吞吐量（高效率的利用 CPU），所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值<ul><li>CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）</li></ul></li><li><img src="/static/IT/JVM/JVM-GC-7.png" alt="Parallel&nbsp;Scavenge"></li><li>Parallel&nbsp;Old 收集器是 Parallel&nbsp;Scavenge 收集器的老年代版本<ul><li>使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑&nbsp;Parallel&nbsp;Scavenge收集器和Parallel&nbsp;Old收集器</li></ul></li></ul></li><li>ParNew 收集器 (-XX:+UseParNewGC)<ul><li>新生代采用复制算法，老年代采用标记-整理算法</li><li>跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用</li><li>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作</li><li><img src="/static/IT/JVM/JVM-GC-8.png" alt="ParNew"></li></ul></li><li>CMS收集器 (-XX:+UseConcMarkSweepGC(old))<ul><li>“标记-清除” 算法，也可以通过JVM参数调节内存整理的时机</li><li>CMS（Concurrent&nbsp;Mark&nbsp;Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</li><li>运作过程<ul><li><img src="/static/IT/JVM/JVM-GC-9.png" alt="CMS"></li><li>初始标记：&nbsp;暂停所有的其他线程(STW)，并记录下gc&nbsp;roots直接能引用的对象，速度很快</li><li>并发标记：&nbsp;并发标记阶段就是从GC&nbsp;Roots的直接关联对象开始遍历整个对象图的过程，&nbsp;这个过程耗时较长但是不需要停顿用户线程，&nbsp;可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变</li><li>重新标记：&nbsp;重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记</li><li>并发清理：&nbsp;开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理</li><li>并发重置：重置本次GC过程中的标记数据</li></ul></li><li>主要优点：并发收集、低停顿</li><li>缺点<ul><li>对CPU资源敏感（会和服务抢资源）</li><li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数<code>-XX:+UseCMSCompactAtFullCollection</code>可以让jvm在执行完标记清除后再做整理</li><li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full&nbsp;gc，也就是"concurrent&nbsp;mode&nbsp;failure"，此时会进入stop&nbsp;the&nbsp;world，用 serial&nbsp;old 垃圾收集器来回收</li></ul></li><li>核心参数<ul><li>-XX:+UseConcMarkSweepGC：启用cms</li><li>-XX:ConcGCThreads：并发的GC线程数</li><li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</li><li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</li><li>-XX:CMSInitiatingOccupancyFraction:&nbsp;当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li><li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li><li>-XX:+CMSScavengeBeforeRemark：在CMS&nbsp;GC前启动一次minor&nbsp;gc，目的在于减少老年代对年轻代的引用，降低CMS&nbsp;GC的标记阶段时的开销，一般CMS的GC耗时&nbsp;80%都在标记阶段</li><li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li><li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW</li></ul></li></ul></li></ul><hr><h2 id="CMS-调优">CMS 调优</h2><p><img src="/static/IT/JVM/JVM-GC-10.png" alt="ParNew + CMS 调优"></p><p><img src="/static/IT/JVM/JVM-GC-11.png" alt=""></p><ul><li>由于动态对象年龄判断原则（业务高峰期）导致频繁 full&nbsp;gc<ul><li>扩大新生代</li><li>将默认的15岁改小一点，比如改为5，避免一直占用survivor区空间</li><li>1M 的大对象直接进入老年代</li><li>CMS 碎片整理</li></ul></li><li>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor&nbsp;gc的时候这些对象都会被回收，不会进到老年代从而导致 full&nbsp;gc</li></ul><hr><h2 id="三色标记">三色标记</h2><ul><li>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生</li><li>把GC roots可达性分析遍历对象过程中遇到的对象，&nbsp;按照“是否访问过”这个条件标记成以下三种颜色<ul><li>黑色：&nbsp;表示对象已经被垃圾收集器访问过，&nbsp;且这个对象的所有引用都已经扫描过。&nbsp;黑色的对象代表已经扫描过，&nbsp;它是安全存活的，&nbsp;如果有其他对象引用指向了黑色对象，&nbsp;无须重新扫描一遍。&nbsp;黑色对象不可能直接（不经过灰色对象）&nbsp;指向某个白色对象</li><li>灰色：&nbsp;表示对象已经被垃圾收集器访问过，&nbsp;但这个对象上至少存在一个引用还没有被扫描过</li><li>白色：&nbsp;表示对象尚未被垃圾收集器访问过。&nbsp;显然在可达性分析刚刚开始的阶段，&nbsp;所有的对象都是白色的，&nbsp;若在分析结束的阶段，&nbsp;仍然是白色的对象，&nbsp;即代表不可达</li><li><img src="/static/IT/JVM/JVM-GC-12.png" alt="三色标记"></li></ul></li><li>多标-浮动垃圾<ul><li>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gc root)被销毁，这个gc root引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”</li><li>浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除</li><li>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分</li></ul></li><li>漏标-读写屏障<ul><li>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决<ul><li>增量更新（Incremental Update）：&nbsp;黑色对象一旦新插入了指向白色对象的引用之后，&nbsp;它就变回灰色对象了<ul><li>当黑色对象插入新的指向白色对象的引用关系时，&nbsp;就将这个新插入的引用记录下来，&nbsp;等并发扫描结束之后，&nbsp;再将这些记录过的引用关系中的黑色对象为根，&nbsp;重新扫描一次</li></ul></li><li>原始快照（Snapshot&nbsp;At&nbsp;The&nbsp;Beginning，SATB）：在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾<ul><li>当灰色对象要删除指向白色对象的引用关系时，&nbsp;就将这个要删除的引用记录下来，&nbsp;在并发扫描结束之后，&nbsp;再将这些记录过的引用关系中的灰色对象为根，&nbsp;重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色</li></ul></li></ul></li><li>无论是对引用关系记录的插入还是删除，&nbsp;虚拟机的记录操作都是通过写屏障实现的</li></ul></li><li>读写屏障<ul><li>写屏障：就是指在赋值操作前后，加入一些处理<ul><li>写屏障实现增量更新：当对象A的成员变量的引用发生变化时，比如新增引用（a.d&nbsp;=&nbsp;d），我们可以利用写屏障，将A新的成员变量引用对象D记录下来</li><li>写屏障实现SATB：当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d&nbsp;=&nbsp;null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来</li></ul></li><li>读屏障：当读取成员变量时，一律记录下来</li><li>并发标记时对漏标的处理方案如下<ul><li>CMS：写屏障&nbsp;+&nbsp;增量更新</li><li>G1，Shenandoah：写屏障&nbsp;+&nbsp;SATB</li><li>ZGC：读屏障</li></ul></li><li>读写屏障还有其他功能<ul><li>写屏障可以用于记录跨代/区引用的变化</li><li>读屏障可以用于支持移动对象的并发执行</li></ul></li></ul></li><li>为什么G1用SATB？CMS用增量更新？<ul><li>SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象</li><li>CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描</li></ul></li></ul><hr><h2 id="记忆集与卡表">记忆集与卡表</h2><ul><li>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了</li><li>为此，在新生代可以引入记录集（Remember&nbsp;Set）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围<ul><li>并不只是新生代、&nbsp;老年代之间才有跨代引用的问题，&nbsp;所有涉及部分区域收集（Partial&nbsp;GC）&nbsp;行为的垃圾收集器，&nbsp;典型的如G1、&nbsp;ZGC和Shenandoah收集器，&nbsp;都会面临相同的问题</li></ul></li><li>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节</li><li>hotspot使用一种叫做“卡表”(cardtable)的方式实现记忆集，也是目前最常用的一种方式</li><li>卡表是使用一个字节数组实现：<code>CARD_TABLE[]</code>，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”，hotSpot使用的卡页是2^9大小，即512字节<ul><li><img src="/static/IT/JVM/JVM-GC-13.png" alt="卡表"></li><li>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0</li></ul></li><li>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里</li><li>使用写屏障维护卡表状态</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;垃圾收集算法&lt;/li&gt;
&lt;li&gt;垃圾收集器&lt;/li&gt;
&lt;li&gt;CMS 调优&lt;/li&gt;
&lt;li&gt;三色标记&lt;/li&gt;
&lt;li&gt;记忆集与卡表&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;垃圾收集算法&quot;&gt;垃圾收集算法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/stati</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-类加载机制</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-lei-jia-zai-ji-zhi/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-lei-jia-zai-ji-zhi/</id>
    <published>2024-09-09T01:14:00.000Z</published>
    <updated>2024-09-09T01:17:44.151Z</updated>
    
    <content type="html"><![CDATA[<ul><li>loadClass 的类加载过程有如下几步（使用到时才加载）：加载&nbsp;&gt;&gt;&nbsp;验证&nbsp;&gt;&gt;&nbsp;准备&nbsp;&gt;&gt;&nbsp;解析&nbsp;&gt;&gt;&nbsp;初始化&nbsp;&gt;&gt;&nbsp;使用&nbsp;&gt;&gt;&nbsp;卸载<ul><li><img src="/static/IT/JVM/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1.png" alt="loadClass"></li><li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载<ul><li>在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li>验证：校验字节码文件的正确性</li><li>准备：给类的静态变量分配内存，并赋予默认值</li><li>解析：将符号引用替换为直接引用（静态链接过程）<ul><li>静态链接过程（类加载期间完成）：该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存内存的指针或句柄等（直接引用）</li><li>动态链接是在程序运行期间完成的将符号引用替换为直接引用</li></ul></li><li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li></ul></li><li>类被加载到方法区中后主要包含：运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息<ul><li>类加载器的引用：这个类到类加载器实例的引用</li><li>对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的 Class&nbsp;类型的对象实例放到堆(Heap)中,&nbsp;作为开发人员访问方法区中类定义的入口和切入点</li></ul></li><li>类加载器<ul><li>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库</li><li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR</li><li>应用程序类加载器：负责加载 ClassPath 路径下的类包</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ul></li><li>类加载器初始化过程<ul><li>创建JVM启动器实例 sun.misc.Launcher （单例）</li><li>在Launcher构造方法内部，创建了两个类加载器<ul><li>sun.misc.Launcher.ExtClassLoade（扩展类加载器）</li><li>sun.misc.Launcher.AppClassLoader（应用类加载器）</li></ul></li><li>JVM 默认使用 Launcher 的 getClassLoader() 方法返回的类加载器 AppClassLoader 的实例加载我们的应用程序</li></ul></li><li>双亲委派机制：先找父亲加载，不行再由儿子自己加载<ul><li><img src="/static/IT/JVM/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-2.png" alt="双亲委派"><ul><li>加载某个类时会先委托父加载器寻找目标类</li><li>找不到再委托上层父加载器加载</li><li>如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类</li></ul></li><li>AppClassLoader 的 loadClass 方法最终会调用其父类 ClassLoader 的 loadClass 方法<ul><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name,&nbsp;false);</code>）或者是调用 bootstrap 类加载器来加载</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass 方法来完成类加载</li></ul></li><li>为什么要设计双亲委派机制<ul><li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li><li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li></ul></li></ul></li><li>自定义类加载器：继承&nbsp;java.lang.ClassLoader&nbsp;类，主要是重写 findClass 方法<ul><li>也可以重写 loadClass 方法打破双亲委派（[[…/Tomcat/Tomcat-类加载机制&amp;热加载&amp;热部署|Tomcat-类加载机制&amp;热加载&amp;热部署]]）</li></ul></li><li>全盘负责委托机制：当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入</li><li>同一个 JVM 内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个</li></ul><hr><p><img src="/static/IT/JVM/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-3.png" alt="通过 Java 命令执行代码的大体流程"></p><p><img src="/static/IT/JVM/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-4.png" alt="Hotspot 源码 JVM 启动执行 main 方法的流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;loadClass 的类加载过程有如下几步（使用到时才加载）：加载&amp;nbsp;&amp;gt;&amp;gt;&amp;nbsp;验证&amp;nbsp;&amp;gt;&amp;gt;&amp;nbsp;准备&amp;nbsp;&amp;gt;&amp;gt;&amp;nbsp;解析&amp;nbsp;&amp;gt;&amp;gt;&amp;nbsp;初始化&amp;nbsp;&amp;gt</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-对象创建&amp;内存分配</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-dui-xiang-chuang-jian-nei-cun-fen-pei/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-dui-xiang-chuang-jian-nei-cun-fen-pei/</id>
    <published>2024-09-09T01:08:00.000Z</published>
    <updated>2024-09-09T01:11:48.290Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对象的创建</li><li>对象内存分配</li><li>对象内存回收</li></ul><hr><h2 id="对象的创建">对象的创建</h2><p><img src="/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1.png" alt="对象的创建"></p><ol><li>类加载检查：&nbsp;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等</li><li>分配内存：对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来<ul><li>划分内存的方法<ul><li>“指针碰撞”（Bump&nbsp;the&nbsp;Pointer）(默认用指针碰撞)<ul><li>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li></ul></li><li>“空闲列表”（Free&nbsp;List）<br>- 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例并更新列表上的记录</li></ul></li><li>在并发情况下，&nbsp;可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况<ul><li>CAS（compare&nbsp;and&nbsp;swap）：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理</li><li>本地线程分配缓冲（Thread&nbsp;Local&nbsp;Allocation&nbsp;Buffer, TLAB）：<code>­XX:+UseTLAB­</code> 默认开启 <code>-­XX:TLABSize</code>&nbsp;指定 TLAB 大小<ul><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存</li></ul></li></ul></li></ul></li><li>初始化：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）<ul><li>如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行</li><li>这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</li></ul></li><li>设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object&nbsp;Header之中<ul><li>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、&nbsp;实例数据（Instance&nbsp;Data）和对齐填充（Padding）</li><li><img src="/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-2.png" alt="对象头"><ul><li>HotSpot虚拟机的对象头包括两部分信息<ul><li>第一部分用于存储对象自身的运行时数据，&nbsp;如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li><li>另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul></li></ul></li></ul></li><li>执行<code>&lt;init&gt;</code>方法：即对象按照程序员的意愿进行初始化<ul><li>对应到语言层面上讲，就是为属性赋值（这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法</li></ul></li></ol><ul><li>对象大小与指针压缩：可以用 jol­core 包查看<ul><li>指针压缩<ul><li>jvm 配置参数：<code>UseCompressedOops</code><ul><li>compressed­­ 压缩、oop(ordinary&nbsp;object&nbsp;pointer)­­ 对象指针</li></ul></li><li>启用指针压缩：<code>XX:+UseCompressedOops</code>（默认开启）</li><li>禁止指针压缩：­<code>-XX:­UseCompressedOops</code></li></ul></li></ul></li><li>为什么要进行指针压缩<ul><li>在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力</li><li>为了减少64位平台下内存的消耗，启用指针压缩功能</li><li>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</li><li>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</li><li>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现内存使用多出1.5倍左右的问题，所以堆内存不要大于32G为好</li></ul></li></ul><hr><h2 id="对象内存分配">对象内存分配</h2><p><img src="/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-3.png" alt="对象内存分配"></p><ul><li>对象栈上分配：逃逸分析（<code>-XX:+DoEscapeAnalysis</code>）、标量替换（<code>-XX:+EliminateAllocations</code>）<ul><li>JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能，为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问<ul><li>如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力</li></ul></li><li>逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用</li><li>标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配</li><li>标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及 reference 类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一 步分解的聚合量</li></ul></li><li>对象在Eden区分配：大多数情况下，对象在新生代中&nbsp;Eden&nbsp;区分配（当&nbsp;Eden&nbsp;区没有足够空间进行分配时，虚拟机将发起一次 Minor&nbsp;GC）<ul><li>Minor&nbsp;GC/Young&nbsp;GC：指发生新生代的的垃圾收集动作，Minor&nbsp;GC非常频繁，回收速度一般也比较快</li><li>Major&nbsp;GC/Full&nbsp;GC：一般会回收老年代&nbsp;，年轻代，方法区的垃圾，Major&nbsp;GC的速度一般会比Minor&nbsp;GC的慢10倍以上</li><li>Eden与Survivor区默认 8:1:1（让eden区尽量的大，survivor区够用即可）<ul><li><code>-XX:+UseAdaptiveSizePolicy</code> 默认开启，会导致这个 8:1:1 比例自动变化</li><li>大量的对象被分配在eden区，eden区满了后会触发minor&nbsp;gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor&nbsp;gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的</li><li>如果对象太大无法存入Survior空间，就会提前转移到老年代</li></ul></li></ul></li><li>大对象直接进入老年代：为了避免为大对象分配内存时的复制操作而降低效率<ul><li><code>-XX:PretenureSizeThreshold</code> 如果对象超过设置大小会直接进入老年代（这个参数只在&nbsp;Serial&nbsp;和ParNew两个收集器下有效）</li></ul></li><li>长期存活的对象将进入老年代：<code>-XX:MaxTenuringThreshold</code> （对象晋升到老年代的年龄阈值）<ul><li>如果对象在&nbsp;Eden&nbsp;出生并经过第一次&nbsp;Minor&nbsp;GC&nbsp;后仍然能够存活，并且能被&nbsp;Survivor&nbsp;容纳的话，将被移动到&nbsp;Survivor&nbsp;空间中，并将对象年龄设为 1</li><li>对象在&nbsp;Survivor&nbsp;中每熬过一次&nbsp;MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁），就会被晋升到老年代中</li></ul></li><li>对象动态年龄判断：<code>-XX:TargetSurvivorRatio</code> 希望那些可能是长期存活的对象，尽早进入老年代<ul><li>对象动态年龄判断机制一般是在 minor&nbsp;gc 之后触发的</li><li>当前放对象的Survivor区域里（其中一块区域，放对象的那块Survivor区），一批对象的总大小大于这块Survivor区域内存大小的50%（<code>-XX:TargetSurvivorRatio</code>），那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了<ul><li>例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</li></ul></li></ul></li><li>老年代空间分配担保机制<ul><li><img src="/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-4.png" alt="老年代空间分配担保机制"></li><li>年轻代每次minor&nbsp;gc之前JVM都会计算下老年代剩余可用空间<ul><li>如果这个可用空间小于年轻代里现有的所有对象大小之和（包括垃圾对象）</li><li>就会看一个<code>-XX:-HandlePromotionFailure</code> (jdk1.8默认就设置了) 的参数是否设置了<ul><li>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor&nbsp;gc后进入老年代的对象的平均大小</li><li>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full&nbsp;gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生"OOM"</li></ul></li></ul></li><li>如果minor&nbsp;gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full&nbsp;gc，full&nbsp;gc完之后如果还是没有空间放minor&nbsp;gc之后的存活对象，则也会发生“OOM”</li></ul></li></ul><hr><h2 id="对象内存回收">对象内存回收</h2><ul><li>判断哪些对象已经死亡<ul><li>引用计数法（循环引用问题）：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的<ul><li>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题</li></ul></li><li>可达性分析算法<ul><li><img src="/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-5.png" alt="可达性分析算法"></li><li>将“GC&nbsp;Roots”&nbsp;对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象<ul><li>GC&nbsp;Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li></ul></li></ul></li></ul></li><li>常见引用类型<ul><li>强引用：普通的变量引用</li><li>软引用（可用来实现内存敏感的高速缓存）：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉3</li><li>弱引用：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用</li><li>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li></ul></li><li>finalize() 方法最终判定对象是否存活<ul><li>标记的前提是对象在进行可达性分析后发现没有与GC&nbsp;Roots相连接的引用链</li><li>第一次标记并进行一次筛选<ul><li>筛选的条件是此对象是否有必要执行finalize()方法</li><li>当对象没有覆盖finalize方法，对象将直接被回收</li></ul></li><li>第二次标记：对象覆盖了finalize方法<ul><li>只要重新与引用链上的任何的一个对象建立关联，那在第二次标记时它将移除出“即将回收”的集合</li></ul></li></ul></li><li>如何判断一个类是无用的类（方法区主要回收的是无用的类）<ul><li>该类所有的实例都已经被回收，也就是&nbsp;Java&nbsp;堆中不存在该类的任何实例</li><li>加载该类的&nbsp;ClassLoader&nbsp;已经被回收</li><li>该类对应的&nbsp;java.lang.Class&nbsp;对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;对象的创建&lt;/li&gt;
&lt;li&gt;对象内存分配&lt;/li&gt;
&lt;li&gt;对象内存回收&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/static/IT/JVM/JVM-%E5%AF%B9%E8%B1%A1%</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-调优</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-diao-you/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-diao-you/</id>
    <published>2024-09-09T01:06:00.000Z</published>
    <updated>2024-09-09T01:06:50.411Z</updated>
    
    <content type="html"><![CDATA[<ul><li>jps 查看进程 id</li><li>Jmap 查看内存信息，实例个数以及占用内存大小<ul><li><code>jmap -histo pid</code></li><li><code>jmap&nbsp;‐dump:format=b,file=eureka.hprof&nbsp;14660</code></li></ul></li><li>Jstack 查找死锁<ul><li><code>jstack&nbsp;19663 | grep&nbsp;-A&nbsp;10&nbsp;4cd0</code></li><li>需要把 top 里的 tid 转为十六进制</li></ul></li><li>Jinfo&nbsp;查看正在运行的Java应用程序的扩展参数</li><li>Jstat 查看堆内存各部分的使用量，以及加载类的数量<ul><li>jstat -gcutil pid</li><li>jstat&nbsp;-gc&nbsp;pid 垃圾回收统计<ul><li>年轻代对象增长的速率</li><li>Young&nbsp;GC的触发频率和每次耗时</li><li>每次 Young&nbsp;GC 后有多少对象存活和进入老年代</li><li>Full&nbsp;GC 的触发频率和每次耗时</li></ul></li><li>jstat -gccapacity pid 堆内存统计</li><li>jstat -gcnew pid 新生代垃圾回收统计</li><li>jstat -gcnewcapacity pid 新生代内存统计</li><li>jstat -gcold pid 老年代垃圾回收统计</li><li>jstat -gcoldcapacity pid 老年代内存统计</li><li>jstat -gcmetacapacity 元数据空间统计</li></ul></li><li>jvisualvm</li><li>Arthas：dashboard；thread；ognl</li><li>内存溢出自动导出dump文件：<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code></li><li>GC日志：<code>‐XX:+PrintGCDetails</code></li><li><code>java&nbsp;-XX:+PrintFlagsInitial</code>&nbsp;表示打印出所有参数选项的默认值</li><li><code>java&nbsp;-XX:+PrintFlagsFinal</code>&nbsp;表示打印出所有参数选项在运行程序时生效的值</li></ul><hr><ul><li>优化思路：尽量让每次Young&nbsp;GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full&nbsp;GC的频率，避免频繁Full&nbsp;GC对JVM性能的影响</li><li>系统频繁Full&nbsp;GC导致系统卡顿：结合对象挪动到老年代那些规则推理下程序可能存在的一些问题<ul><li>尤其是对象动态年龄判断机制：把年轻代适当调大点</li><li>老年代空间分配担保机制<ul><li>大对象问题：jmap -histo pid 找出大对象（结合cpu占用较高的线程），然后优化代码</li></ul></li></ul></li><li>内存泄露<ul><li>一些老旧数据没有及时清理导致一直占用内存，时间长了除了导致 full&nbsp;gc，还有可能导致 OOM<ul><li>hashmap存放缓存数据而没设置淘汰算法</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;jps 查看进程 id&lt;/li&gt;
&lt;li&gt;Jmap 查看内存信息，实例个数以及占用内存大小
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jmap -histo pid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jmap&amp;nbsp;‐dump:format=b,file=eu</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-常量池</title>
    <link href="https://jxch.github.io/2024/09/09/architect/jvm/jvm-chang-liang-chi/"/>
    <id>https://jxch.github.io/2024/09/09/architect/jvm/jvm-chang-liang-chi/</id>
    <published>2024-09-09T01:00:00.000Z</published>
    <updated>2024-09-09T01:03:01.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Class 常量池与运行时常量池（<code>javap&nbsp;-v&nbsp;Xxx.class</code> -&gt; Constant pool）：常量池中主要存放字面量和符号引用<ul><li>Class常量池可以理解为是Class文件中的资源仓库<ul><li>Class文件中除了包含类的版本、字段、方法、接口等描述信息外， 还有一项信息就是常量池(constant&nbsp;pool&nbsp;table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic&nbsp;References)</li></ul></li><li>字面量：就是指由字母、数字等构成的字符串或者数值常量<ul><li>字面量只可以右值出现，所谓右值是指等号右边的值，如：int&nbsp;a=1&nbsp;这里的a为左值，1为右值</li></ul></li><li>符号引用：是编译原理中的概念，是相对于直接引用来说的<ul><li>主要包括了三类常量：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符</li></ul></li><li>运行时常量池：这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成运行时常量池<ul><li>例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的 地址，主要通过对象头里的类型指针去转换直接引用</li></ul></li></ul></li><li>字符串常量池<ul><li>设计思想<ul><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能</li><li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化<ul><li>为字符串开辟一个字符串常量池，类似于缓存区</li><li>创建字符串常量时，首先查询字符串常量池是否存在该字符串</li><li>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</li></ul></li></ul></li><li>三种字符串操作<ul><li>直接赋值字符串（指向常量池中的引用）：<code>String&nbsp;s&nbsp;=&nbsp;"jxch";</code><ul><li>这种方式创建的字符串对象，只会在常量池中</li><li>创建对象s的时候，JVM会先去常量池中通过&nbsp;equals(key)&nbsp;方法，判断是否有相同的对象<ul><li>如果有，则直接返回该对象在常量池中的引用</li><li>如果没有，则会在常量池中创建一个新对象，再返回引用</li></ul></li></ul></li><li><code>String s = new&nbsp;String("jxch");</code> （指向内存中的对象引用）<ul><li>这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用</li><li>先检查字符串常量池中是否存在字符串<ul><li>不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象</li><li>存在的话，就直接去堆内存中创建一个字符串对象</li></ul></li><li>最后，将内存中的引用返回</li></ul></li><li><code>intern</code> 方法是一个&nbsp;native&nbsp;的方法<ul><li>如果池已经包含一个等于此String对象的字符串（equals(oject)），则返回池中的字符串</li><li>否则，将intern返回的引用指向当前字符串<ul><li>在&nbsp;JDK&nbsp;1.7&nbsp;(及以上版本) 中，由于字符串池不在永久代了，intern()&nbsp;做了一些修改，更方便地利用堆中的对象（字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例）</li><li>jdk1.6版本需要将字符串复制到字符串常量池里</li></ul></li></ul></li></ul></li><li>常量池的位置<ul><li>Jdk1.6及之前：&nbsp;有永久代,&nbsp;运行时常量池在永久代，运行时常量池包含字符串常量池</li><li>Jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里</li><li>Jdk1.8及之后：&nbsp;无永久代，运行时常量池在元空间，字符串常量池里依然在堆里</li></ul></li><li>设计原理：类似 HashTable ，本质上是字符串对象的引用</li></ul></li><li>八种基本类型的包装类和对象池<ul><li>java中基本类型的包装类的大部分都实现了常量池技术 (严格来说应该叫对象池，在堆上)</li><li>Byte,Short,Integer,Long,Character,Boolean （另外两种浮点数类型的包装类则没有实现对象池）</li><li>Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池<ul><li>即对象不负责创建和管理大于127的这些类的对象</li><li>一般这种比较小的数用到的概率相对较大</li></ul></li></ul></li></ul><hr><h2 id="字符串常量池示例">字符串常量池示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"he"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"llo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在 JDK 1.6 下输出是 false，创建了 6 个对象</span><span class="token comment">// 在 JDK 1.7 及以上的版本输出是 true，创建了 5 个对象 </span><span class="token comment">// 当然我们这里没有考虑GC，但这些对象确实存在或存在过</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/static/IT/JVM/JVM-%E5%B8%B8%E9%87%8F%E6%B1%A0-1.png" alt="JDK1.7+"></p><p><img src="/static/IT/JVM/JVM-%E5%B8%B8%E9%87%8F%E6%B1%A0-2.png" alt="JDK1.6"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"zhuge"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token string">"zhuge"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token string">"zhu"</span> <span class="token operator">+</span> <span class="token string">"ge"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"zhuge"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"zhuge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token string">"zhu"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s2 <span class="token punctuation">)</span>； <span class="token comment">// false </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s1<span class="token operator">==</span>s2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"a1"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"atrue"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"true"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"a3.4"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token number">3.4</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> bb<span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false 由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> bb<span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token function">getBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> bb<span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false JVM对于字符串引用bb，它的值在编译期无法确定，只能在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b</span><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ja"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"va"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>String是不可变的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span> <span class="token operator">+</span> <span class="token string">"c"</span><span class="token punctuation">;</span> <span class="token comment">//就等价于String s = "abc";</span><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">"c"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s1 <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>s1&nbsp;这个就不一样了，可以通过观察其JVM指令码发现s1的"+"操作会变成如下操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> temp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="包装类对象池示例">包装类对象池示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span><span class="token comment">//在值小于127时可以使用对象池</span><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span> <span class="token comment">//这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池 </span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出true</span>  <span class="token comment">//值大于127时，不会从对象池中取对象</span> <span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span> <span class="token class-name">Integer</span> i4 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出false</span>  <span class="token comment">//用new关键词新生成对象不会使用对象池</span> <span class="token class-name">Integer</span> i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Integer</span> i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i5 <span class="token operator">==</span> i6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出false</span>  <span class="token comment">//Boolean类也实现了对象池技术</span> <span class="token class-name">Boolean</span> bool1 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token class-name">Boolean</span> bool2 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bool1 <span class="token operator">==</span> bool2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出true</span>  <span class="token comment">//浮点类型的包装类没有实现对象池技术</span> <span class="token class-name">Double</span> d1 <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token class-name">Double</span> d2 <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d1 <span class="token operator">==</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Class 常量池与运行时常量池（&lt;code&gt;javap&amp;nbsp;-v&amp;nbsp;Xxx.class&lt;/code&gt; -&amp;gt; Constant pool）：常量池中主要存放字面量和符号引用
&lt;ul&gt;
&lt;li&gt;Class常量池可以理解为是Class文件中的资源</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://jxch.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Netty-调优</title>
    <link href="https://jxch.github.io/2024/09/06/architect/netty/netty-diao-you/"/>
    <id>https://jxch.github.io/2024/09/06/architect/netty/netty-diao-you/</id>
    <published>2024-09-06T02:51:49.000Z</published>
    <updated>2024-09-06T02:51:44.569Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Selector BUG 会导致 Selector 空轮询，最终导致CPU 100%（JDK1.8 的131 版本中依然存在）<ul><li>JDK 认为linux 的epoll 告诉我事件来了，但是 JDK 没有拿到任何事件(READ、WRITE、CONNECT、ACCPET)，但此时select()方法不再选择阻塞了，而是选择返回了 0，于是就会进入一种无限循环，导致 CPU 100%</li><li>在部分Linux 的 2.6 的 kernel 中，poll 和epoll 对于突然中断的连接socket 会对返回的 eventSet 事件集合置为POLLHUP 或POLLERR，eventSet 事件集合发生了变化，这就可能导致Selector 会被唤醒</li><li>但是这个时候selector 的select 方法返回numKeys是0，所以下面本应该对 key 值进行遍历的事件处理根本执行不了，又回到最上面的while(true)循环，循环往复，不断的轮询，直到 linux 系统出现100%的 CPU 情况</li></ul></li><li>Netty 是如何解决JDK 中的Selector BUG 的<ul><li>对 Selector 的 select 操作周期进行统计，每完成一次空的 select 操作进行一次计数，若在某个周期内连续发生N 次空轮询，则触发了epoll 死循环 bug</li><li>重建Selector，判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的Selector上去除注册，重新注册到新的 Selector 上，并将原来的 Selector 关闭</li></ul></li><li>如何让单机下Netty 支持百万长连接<ul><li>操作系统：<code>ulimit –n 1000000</code>（默认1024）<ul><li>如果修改失败：<ul><li>修改/etc/security/limits.conf 文件<ul><li><code>soft nofile 1000000</code>：软限制， 表示警告的限制</li><li><code>hard nofile 1000000</code>：硬限制，表示真正限制</li></ul></li><li>修改/etc/pam.d/login 文件<ul><li><code>session required /lib/security/pam_limits.so</code><ul><li>在用户完成系统登录后，应该调用pam_limits.so 模块来设置系统对该用户可使用的各种资源数量的最大限制（包括用户可打开的最大文件数限制），而pam_limits.so模块就会从/etc/security/limits.conf 文件中读取配置来设置这些限制值</li></ul></li></ul></li><li>修改 sysctl.conf 文件：系统级硬限制<ul><li><code>fs.file_max = 1000000</code></li><li><code>sysctl -p</code></li></ul></li></ul></li></ul></li></ul></li><li>设置合理的线程数<ul><li>如果发现IO 线程的热点停留在读或者写操作,或者停留在 Channelhandler 的执行处，则可以通过适当调大 Nio EventLoop 线程的个数来提升网络的读写性能</li><li>如果连续采集几次进行对比,发现线程堆栈都停留在 Selectorlmpl. lockAndDoSelect，则说明IO 线程比较空闲,无须对工作线程数做调整</li></ul></li><li>心跳优化<ul><li>要能够及时检测失效的连接,并将其剔除,防止无效的连接句柄积压,导致OOM 等问题</li><li>设置合理的心跳周期,防止心跳定时任务积压,造成频繁的老年代GC</li><li>使用Nety 提供的链路空闲检测机制，不要自己创建定时任务线程池，加重系统的负担<ul><li>读空闲, 链路持续时间T 没有读取到任何消息</li><li>写空闲, 链路持续时间T 没有发送任何消息</li><li>读写空闲, 链路持续时间T 没有接收或者发送任何消息</li></ul></li><li>对于百万级的服务器，一般不建议很长的心跳周期和超时时长</li></ul></li><li>接收和发送缓冲区调优<ul><li>在一些场景下, 端侧设备会周期性地上报数据和发送心跳, 单个链路的消息收发量并不大, 针对此类场景, 可以通过调小 TCP 的接收和发送缓冲区来降低单个TCP 连接的资源占用率</li><li>当然对于不同的应用场景, 收发缓冲区的最优值可能不同, 用户需要根据实际场景, 结合性能测试数据进行针对性的调优</li></ul></li><li>合理使用内存池：堆外直接内存和堆内存<ul><li>由于 DirectByteBuf 的创建成本比较高, 因此如果使用 DirectByteBuf, 则需要配合内存池使用,否则性价比可能还不如 Heap Byte</li><li>Netty 默认的IO 读写操作采用的都是内存池的堆外直接内存模式, 如果用户需要额外使 用 ByteBuf, 建议也采用内存池方式; 如果不涉及网络IO 操作 (只是纯粹的内存操作), 可以使用堆内存池, 这样内存的创建效率会更高一些</li></ul></li><li>IO 线程和业务线程分离<ul><li>如果服务端不做复杂的业务逻辑操作, 仅是简单的内存操作和消息转发, 则可以通过调大 NioEventLoop 工作线程池的方式,直接在IO 线程中执行业务 Channelhandler, 这样便减少了一次线程上下文切换,性能反而更高</li><li>如果有复杂的业务逻辑操作, 则建议IO 线程和业务线程分离, 对于IO 线程, 由于互相之间不存在锁竞争, 可以创建一个大的 NioEvent Loop Group 线程组, 所有 Channel 都共享同一个线程池</li><li>对于后端的业务线程池, 则建议创建多个小的业务线程池,线程池可以与 IO 线程绑定, 这样既减少了锁竞争, 又提升了后端的处理性能</li></ul></li><li>针对端侧并发连接数的流控：FlowControlchannelhandler<ul><li>加到 ChannelPipeline 靠前的位置</li><li>覆盖 channelActive() 方法</li><li>如果达到流控阈值, 则拒绝该连接, 调用 ChannelHandler Context 的 close 方法关闭连接</li></ul></li><li>JVM 层面相关性能优化<ul><li>GC：吞吐量、延迟和内存占用不能兼得<ul><li>GC 数据的采集和研读</li><li>设置合适的 JVM 堆大小</li><li>选择合适的垃圾回收器和回收策略</li></ul></li></ul></li><li>水平触发 (LT)<ul><li>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写</li><li>如果这次没有把数据一次性全部读写完，那么下次调用 epoll_wait() 时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你</li></ul></li><li>边缘触发 (ET)：比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符<ul><li>当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写</li><li>如果这次没有把数据全部读写完，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你</li></ul></li><li>触发模式<ul><li>select()，poll()模型都是水平触发模式</li><li>信号驱动IO 是边缘触发模式</li><li>epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发</li><li>JDK 中的select 实现是水平触发</li><li>Netty提供的Epoll 的实现中是边缘触发</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Selector BUG 会导致 Selector 空轮询，最终导致CPU 100%（JDK1.8 的131 版本中依然存在）
&lt;ul&gt;
&lt;li&gt;JDK 认为linux 的epoll 告诉我事件来了，但是 JDK 没有拿到任何事件(READ、WRITE、CONN</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Netty" scheme="https://jxch.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty-常用组件</title>
    <link href="https://jxch.github.io/2024/09/06/architect/netty/netty-chang-yong-zu-jian/"/>
    <id>https://jxch.github.io/2024/09/06/architect/netty/netty-chang-yong-zu-jian/</id>
    <published>2024-09-06T02:32:49.000Z</published>
    <updated>2024-09-06T02:43:09.984Z</updated>
    
    <content type="html"><![CDATA[<ul><li>代码示例</li><li>Bootstrap：引导</li><li>EventLoop(Group)：控制流、多线程处理、并发</li><li>Channel：Socket</li><li>ChannelFuture：异步通知</li><li>ChannelHandler</li><li>ChannelPipeline</li><li>ChannelHandlerContext</li><li>ChannelOption</li><li>ByteBuf</li></ul><hr><h2 id="代码示例">代码示例</h2><ul><li>为什么Netty 使用 NIO 而不是 AIO：Netty5 已经停止开发了<ul><li>Netty 不看重Windows 上的使用，在Linux 系统上，AIO 的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK 封装了一层不容易深度优化</li><li>而且Linux 上AIO 不够成熟，处理回调结果速度跟不上处理需求</li><li>AIO 还有个缺点是接收数据需要预先分配缓存, 而不是NIO 那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况，内存浪费很多</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Server</span><span class="token class-name">EventLoopGroup</span> group  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token comment">// 自定义 EchoServerHandler 做业务处理，可继承 SimpleChannelInboundHandler</span>ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EchoServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>group<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Client</span><span class="token class-name">EventLoopGroup</span> group  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Bootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token comment">// 自定义 EchoClientHandler 做业务处理，可继承 SimpleChannelInboundHandler</span>ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>group<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Netty-组件">Netty 组件</h2><h3 id="Bootstrap：引导">Bootstrap：引导</h3><ul><li>Bootstrap 是 Netty 框架的启动类和主入口类，分为客户端类Bootstrap 和服务器类 ServerBootstrap 两种<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-1.png" alt=""></li><li>引导一个客户端只需要一个EventLoopGroup，但是一个ServerBootstrap则需要两个（也可以是同一个实例），因为服务器需要两组不同的Channel<ul><li>第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字</li><li>第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的Channel</li></ul></li><li>与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel 的EventLoop。一旦连接被接受，第二个EventLoopGroup 就会给它的Channel 分配一个EventLoop</li></ul></li></ul><h3 id="EventLoop-Group-：控制流、多线程处理、并发">EventLoop(Group)：控制流、多线程处理、并发</h3><ul><li>EventLoop 暂时可以看成一个线程、EventLoopGroup 自然就可以看成线程组</li><li>EventLoop 事件循环：循环处理关心的每种事件<ul><li>一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务（Runnable 或者Callable）可以直接提交给EventLoop 实现，以立即执行或者调度执行</li></ul></li><li>线程的分配<ul><li>服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup 中</li><li>异步传输实现只使用了少量的EventLoop（以及和它们相关联的Thread），它们可能会被多个Channel 所共享</li><li>EventLoopGroup 负责为每个新创建的Channel 分配一个EventLoop<ul><li>使用顺序循环（round-robin）的方式进行分配以获取一个均衡的分布</li><li>并且相同的EventLoop 可能会被分配给多个Channel<ul><li>因为一个EventLoop 通常会被用于支撑多个Channel，所以对于所有相关联的Channel 来说，ThreadLocal 都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择</li></ul></li></ul></li><li>一旦一个Channel 被分配给一个EventLoop，它将在它的整个生命周期中都使用这个EventLoop（以及相关联的Thread）</li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-2.png" alt="EventLoop"></li></ul></li><li>线程管理<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-3.png" alt="EventLoop"></li><li>当提交任务到如果（当前）调用线程正是支撑EventLoop 的线程，那么所提交的代码块将会被（直接）执行</li><li>否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中<ul><li>当EventLoop 下次处理它的事件时，它会执行队列中的那些任务/事件</li></ul></li></ul></li><li>内置通信传输模式<ul><li>NIO（NioEventLoopGroup NioServerSocketChannel）：基于选择器的方式</li><li>Epoll（EpollEventLoopGroup EpollServerSocketChannel）：由JNI 驱动的epoll()和非阻塞IO<ul><li>这个传输支持只有在Linux上可用的多种特性，如SO_REUSEPORT，比NIO 传输更快，而且是完全非阻塞的</li></ul></li><li>OIO：使用阻塞流</li><li>Local：可以在VM 内部通过管道进行通信的本地传输</li><li>Embedded：允许使用ChannelHandler 而又不需要一个真正的基于网络的传输<ul><li>在测试ChannelHandler 实现时非常有用</li></ul></li></ul></li></ul><h3 id="Channel：Socket">Channel：Socket</h3><ul><li>Channel 是 Java NIO 的一个基本构造<ul><li>它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O 操作的程序组件）的开放连接，如读操作和写操作</li><li>可以把Channel 看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接</li></ul></li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-4.png" alt="EventLoop"><ul><li>Channel 需要被注册到某个EventLoop 上</li><li>在Channel 整个生命周期内都由这个EventLoop 处理IO 事件（一个Channel 和一个EventLoop 进行了绑定）<ul><li>但是一个EventLoop 可以同时被多个Channel 绑定</li></ul></li></ul></li><li>Channel 接口<ul><li>基本的I/O 操作（bind()、connect()、read()和write()）依赖于底层网络传输所提供的原语<ul><li>其基本的构造是类Socket</li></ul></li><li>Netty 的Channel 接口所提供的API，被用于所有的I/O 操作。大大地降低了直接使用Socket 类的复杂性</li><li>为了保证顺序将Channel 声明为Comparable子接口<ul><li>如果两个不同的Channel 实例都返回了相同的散列码，那么AbstractChannel 中的compareTo()方法的实现将会抛出一个Error</li></ul></li></ul></li><li>Channel 的生命周期状态<ul><li>ChannelUnregistered ：Channel 已经被创建，但还未注册到EventLoop</li><li>ChannelRegistered ：Channel 已经被注册到了EventLoop</li><li>ChannelActive ：Channel 处于活动状态（已经连接到它的远程节点）<ul><li>它现在可以接收和发送数据了</li></ul></li><li>ChannelInactive ：Channel 没有连接到远程节点</li><li>当这些状态发生改变时，将会生成对应的事件<ul><li>这些事件将会被转发给 ChannelPipeline 中的ChannelHandler，其可以随后对它们做出响应</li></ul></li><li>关注ChannelActive 和ChannelInactive 会更多一些</li></ul></li><li>重要Channel 的方法<ul><li>eventLoop： 返回分配给Channel 的EventLoop</li><li>pipeline：返回Channel 的ChannelPipeline，也就是说每个Channel 都有自己的ChannelPipeline</li><li>isActive：如果Channel 是活动的，则返回true；活动的意义可能依赖于底层的传输<ul><li>一个Socket 传输一旦连接到了远程节点便是活动的</li><li>一个Datagram 传输一旦被打开便是活动的</li></ul></li><li>localAddress：返回本地的SokcetAddress</li><li>remoteAddress：返回远程的SocketAddress</li><li>write：将数据写到远程节点<ul><li>这个写只是写往Netty 内部的缓存，还没有真正写往socket</li></ul></li><li>flush：将之前已写的数据冲刷到底层socket 进行传输</li><li>writeAndFlush：一个简便的方法，等同于调用write()并接着调用flush()</li></ul></li></ul><h3 id="ChannelFuture：异步通知">ChannelFuture：异步通知</h3><ul><li>Netty 提供了它自己的实现 ChannelFuture，用于在执行异步操作的时候使用</li><li>一般来说，每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture</li></ul><h3 id="事件">事件</h3><ul><li>Netty 使用不同的事件来通知我们状态的改变或者是操作的状态<ul><li>这使得我们能够基于已经发生的事件来触发适当的动作</li></ul></li><li>Netty 事件是按照它们与入站或出站数据流的相关性进行分类的</li><li>可能由入站数据或者相关的状态更改而触发的事件包括：<ul><li>连接已被激活或者连接失活；数据读取；用户事件；错误事件</li></ul></li><li>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：<ul><li>打开或者关闭到远程节点的连接；将数据写到或者冲刷到套接字</li></ul></li><li>每个事件都可以被分发给ChannelHandler 类中的某个用户实现的方法</li><li>既然事件分为入站和出站<ul><li>用来处理事件的ChannelHandler 也被分为可以处理入站事件的Handler 和出站事件的Handler</li><li>当然有些Handler 既可以处理入站也可以处理出站</li></ul></li><li>Channel、ChannelPipeline 和ChannelHandlerContext 上的事件传播<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-5.png" alt=""></li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-6.png" alt=""></li><li>ChannelHandlerContext 有一些方法也存在于Channel 和Channel-Pipeline 上，但是有一点重要的不同<ul><li>如果调用Channel 或者ChannelPipeline 上的这些方法，它们将沿着整个ChannelPipeline 进行传播</li><li>而调用位于ChannelHandlerContext上的相同方法，则将从当前所关联的ChannelHandler 开始，并且只会传播给位于该ChannelPipeline 中的下一个（入站下一个，出站上一个）能够处理该事件的ChannelHandler</li></ul></li></ul></li></ul><h3 id="ChannelHandler">ChannelHandler</h3><ul><li>Netty 提供了大量预定义的可以开箱即用的 ChannelHandler 实现，也可以自行开发<ul><li>Netty 的主要组件是ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器</li><li>ChannelHandler 的方法是由网络事件触发的</li><li>ChannelHandler 可专门用于几乎任何类型的动作</li></ul></li><li>ChannelHandler 都放在 ChannelPipeline 中统一管理<ul><li>事件就会在ChannelPipeline 中流动，并被其中一个或者多个ChannelHandler 处理</li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-7.png" alt=""></li></ul></li><li>ChannelHandler 的生命周期：在ChannelHandler 被添加到ChannelPipeline 中或者被从ChannelPipeline 中移除时会调用下面这些方法。这些方法中的每一个都接受一个ChannelHandlerContext 参数<ul><li>handlerAdded 当把ChannelHandler 添加到ChannelPipeline 中时被调用</li><li>handlerRemoved 当从ChannelPipeline 中移除ChannelHandler 时被调用</li><li>exceptionCaught 当处理过程中在ChannelPipeline 中有错误产生时被调用</li></ul></li><li>入站和出站ChannelHandler 被安装到同一个ChannelPipeline 中，ChannelPipeline 是双向链表的形式<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-8.png" alt=""><ul><li>如果一个消息或者任何其他的入站事件被读取，那么它会从ChannelPipeline 的头部开始流动，但是只被处理入站事件的Handler 处理</li><li>数据的出站运动（即正在被写的数据）在概念上也是一样的</li></ul></li><li>Netty 能区分入站事件的Handler 和出站事件的Handler，并确保数据只会在具有相同定向类型的两个ChannelHandler 之间传递</li><li>分属出站和入站不同的Handler ，在业务没特殊要求的情况下是无所谓顺序的</li><li>而同属一个方向的Handler 则是有顺序的<ul><li>上一个Handler 处理的结果往往是下一个Handler 的要求的输入</li></ul></li></ul></li><li>ChannelHandler 接口：这些方法和Channel的生命周期密切相关<ul><li>ChannelInboundHandler 接口处理入站数据以及各种状态变化<ul><li>channelRegistered 当Channel 已经注册到它的EventLoop 并且能够处理I/O 时被调用</li><li>channelUnregistered 当Channel 从它的EventLoop 注销并且无法处理任何I/O 时被调用</li><li>channelActive 当Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪</li><li>channelInactive 当Channel 离开活动状态并且不再连接它的远程节点时被调用</li><li>channelReadComplete 当Channel 上的一个读操作完成时被调用</li><li>channelRead 当从Channel 读取数据时被调用</li><li>ChannelWritabilityChanged 当Channel 的可写状态发生改变时被调用<ul><li>可以通过调用Channel 的isWritable()方法来检测Channel 的可写性</li><li>与可写性相关的阈值可以通过<code>Channel.config().setWriteHighWaterMark()</code>和<code>Channel.config().setWriteLowWaterMark()</code>方法来设置</li></ul></li><li>userEventTriggered 当ChannelnboundHandler.fireUserEventTriggered()方法被调用时被调用</li><li>这些方法将会在数据被接收时或者与其对应的Channel 状态发生改变时被调用</li></ul></li><li>ChannelOutboundHandler 接口处理出站数据并且允许拦截所有的操作<ul><li>bind 当请求将Channel 绑定到本地地址时被调用</li><li>connect 当请求将Channel 连接到远程节点时被调用</li><li>disconnect 当请求将Channel 从远程节点断开时被调用</li><li>close 当请求关闭Channel 时被调用</li><li>deregister 当请求将Channel 从它的EventLoop 注销时被调用</li><li>read 当请求从Channel 读取更多的数据时被调用</li><li>flush 当请求通过Channel 将入队数据冲刷到远程节点时被调用</li><li>write 当请求通过Channel 将数据写到远程节点时被调用</li><li>处理出站操作和数据。它的方法将被Channel、ChannelPipeline 以及ChannelHandlerContext 调用</li></ul></li></ul></li><li>ChannelHandler 的适配器<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-9.png" alt=""></li><li>ChannelInboundHandlerAdapter（处理入站）</li><li>ChannelOutboundHandlerAdapter（处理出站）<ul><li>read 方法不是表示读数据，而是表示业务发出了读（read）数据的要求<ul><li>这个要求也会封装为一个事件进行传播，这个事件因为是业务发出到网络的，自然就是个出站事件</li></ul></li></ul></li><li>ChannelDuplexHandler（既要处理入站又要处理出站）</li></ul></li><li>ChannelInitializer：ChannelInboundHandlerAdapter 子类<ul><li>initChannel 提供了一种将多个ChannelHandler 添加到一个ChannelPipeline 中的简便方法</li><li>只需要简单地向 Bootstrap 或 ServerBootstrap 的实例提供你的 ChannelInitializer 实现即可</li><li>并且一旦Channel 被注册到了它的EventLoop 之后，就会调用你的 initChannel()</li><li>在该方法返回之后，ChannelInitializer 的实例将会从ChannelPipeline 中移除它自己</li><li>在我们自己的应用程序中，如果存在着某个handler 只使用一次的情况，也可以仿造ChannelInitializer，用完以后将自己从ChannelPipeline 中移除自己，比如授权handler</li></ul></li><li>Handler 的共享和并发安全性：<ul><li>每个socketChannel 有自己的pipeline 而且每个socketChannel 又是和线程绑定的，所以这些Handler 的实例之间完全独立的，只要Handler 的实例之间不是共享了全局变量， Handler 的实例是线程安全的</li><li>但是如果业务需要我们在多个socketChannel 之间共享一个Handler 的实例<ul><li>ChannelHandlerAdapter 还提供了实用方法 isSharable()</li><li>如果其对应的实现被标注为 <code>@Sharable</code>，那么这个方法将返回 true，表示它可以被添加到多个ChannelPipeline</li></ul></li></ul></li><li>资源管理和 SimpleChannelInboundHandler：会在数据被channelRead0()方法消费之后自动释放数据<ul><li>Netty 在处理网络数据时，同样也需要 Buffer：在Read 网络数据时由Netty 创建Buffer；Write 网络数据时Buffer 往往是由业务方创建的<ul><li>Buffer 用完后都必须进行释放，否则可能会造成内存泄露</li></ul></li><li>在Write 网络数据时，可以确保数据被写往网络了，Netty 会自动进行Buffer 的释放，但是如果Write 网络数据时，我们有outBoundHandler 处理了write()操作并丢弃了数据，没有继续往下写，要由我们负责释放这个Buffer，就必须调用ReferenceCountUtil.release 方法，否则就可能会造成内存泄露</li><li>在Read 网络数据时，如果我们可以确保每个InboundHandler 都把数据往后传递了，也就是调用了相关的fireChannelRead 方法，Netty 也会帮我们释放，同样的，如果我们有InboundHandler 处理了数据，又不继续往后传递，又不调用负责释放的ReferenceCountUtil.release 方法，就可能会造成内存泄露</li><li>自行在编写业务Handler 时，也需要注意这一点：要么继续传递，要么自行释放</li></ul></li></ul><h3 id="ChannelPipeline">ChannelPipeline</h3><ul><li>当Channel 被创建时，它将会被自动地分配一个新的ChannelPipeline，每个Channel 都有自己的ChannelPipeline<ul><li>这项关联是永久性的。在Netty 组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预</li></ul></li><li>ChannelPipeline 提供了ChannelHandler 链的容器<ul><li>并定义了用于在该链上传播入站（也就是从网络到业务处理）和出站（也就是从业务处理到网络）各种事件流的API，我们代码中的ChannelHandler 都是放在ChannelPipeline 中的</li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-10.png" alt=""><ul><li>使得事件流经ChannelPipeline 是ChannelHandler 的工作，它们是在应用程序的初始化或者引导阶段被安装的</li><li>这些ChannelHandler 对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个ChannelHandler</li><li>而且ChannelHandler 对象也完全可以拦截事件不让事件继续传递</li><li>它们的执行顺序是由它们被添加的顺序所决定的</li></ul></li></ul></li><li>ChannelPipeline 上的方法：<ul><li>addFirst、addBefore、addAfter、addLast</li><li>remove 将一个ChannelHandler 从ChannelPipeline 中移除</li><li>replace 将ChannelPipeline 中的一个ChannelHandler 替换为另一个ChannelHandler</li><li>get 通过类型或者名称返回ChannelHandler</li><li>context 返回和ChannelHandler 绑定的ChannelHandlerContext</li><li>names 返回ChannelPipeline 中所有ChannelHandler 的名称</li></ul></li></ul><h3 id="ChannelHandlerContext">ChannelHandlerContext</h3><ul><li>ChannelHandlerContext 代表了ChannelHandler 和ChannelPipeline 之间的关联<ul><li>每当有ChannelHandler 添加到ChannelPipeline 中时，都会创建ChannelHandlerContext</li><li>ChannelHandlerContext 的主要作用就和LinkedList 内部的类Node 类似<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-11.png" alt=""></li></ul></li></ul></li><li>不过ChannelHandlerContext 不仅仅只是个包装类，它还提供了很多的方法<ul><li>比如让事件从当前ChannelHandler 传递给链中的下一个ChannelHandler</li><li>还可以被用于获取底层的Channel</li><li>还可以用于写出站数据</li></ul></li><li>ChannelHandlerContext 的API<ul><li>alloc 返回和这个实例相关联的Channel 所配置的ByteBufAllocator</li><li>bind 绑定到给定的SocketAddress，并返回ChannelFuture</li><li>channel 返回绑定到这个实例的Channel</li><li>close 关闭Channel，并返回ChannelFuture</li><li>connect 连接给定的SocketAddress，并返回ChannelFuture</li><li>deregister 从之前分配的EventExecutor 注销，并返回ChannelFuture</li><li>disconnect 从远程节点断开，并返回ChannelFuture</li><li>executor 返回调度事件的EventExecutor</li><li>fireChannelActive fireChannelInactive fireChannelRead fireChannelReadComplete fireChannelRegistered fireChannelUnregistered fireChannelWritabilityChanged fireExceptionCaught fireUserEventTriggered<ul><li>触发对下一个ChannelInboundHandler 上的特定方法</li></ul></li><li>handler 返回绑定到这个实例的ChannelHandler</li><li>isRemoved 如果所关联的ChannelHandler 已经被从ChannelPipeline 中移除则返回true</li><li>name 返回这个实例的唯一名称</li><li>pipeline 返回这个实例所关联的ChannelPipeline</li><li>read 将数据从Channel 读取到第一个入站缓冲区<ul><li>如果读取成功则触发一个channelRead 事件，并（在最后一个消息被读取完成后）通知ChannelInboundHandler 的channelReadComplete(ctx)方法</li></ul></li><li>write 通过这个实例写入消息并经过ChannelPipeline</li><li>writeAndFlush 通过这个实例写入并冲刷消息并经过ChannelPipeline</li></ul></li><li>ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的</li><li>相对于其他类的同名方法，ChannelHandlerContext 的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能</li></ul><h3 id="ChannelOption">ChannelOption</h3><ul><li>ChannelOption.SO_BACKLOG  对应的是tcp/ip 协议listen 函数中的backlog 参数<ul><li>操作系统里一般有两个队列<ul><li>ACCEPT 队列，保存着已经完成了TCP 的三次握手的连接</li><li>SYN 队列，服务器正在等待TCP 的三次握手完成的队列</li></ul></li><li>BSD 派生系统里backlog 指的就是SYN 队列的大小</li><li>在Linux 的实现里backlog 相对来说，从Linux 2.2 开始，指的是 ACCEPT 队列的长度<ul><li>SYN 队列可以使用<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 设置，默认值为128</li></ul></li><li>如果 backlog 参数大于<code>/proc/sys/net/core/somaxconn</code> 中的值，那么它会被静默截断为值128<ul><li><code>/etc/sysctl.conf</code> 修改这个默认值，包括<code>tcp_max_syn_backlog</code>也可以在此处修改<ul><li><code>sysctl -p</code> 生效</li></ul></li></ul></li></ul></li><li>ChannelOption.SO_REUSEADDR 对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口<ul><li>比如，多网卡（IP）绑定相同端口，比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR 就无法正常使用该端口</li><li>这个参数无法做到让应用绑定完全相同IP + Port 来重复启动</li></ul></li><li>ChannelOption.SO_KEEPALIVE 应于套接字选项中的SO_KEEPALIVE<ul><li>该参数用于设置TCP 连接，当设置该选项以后，连接会测试链接的状态</li><li>这个选项用于可能长时间没有数据交流的连接</li><li>当设置该选项以后，如果在两小时内没有数据的通信时，TCP 会自动发送一个活动探测数据报文</li></ul></li><li>ChannelOption.SO_SNDBUF 对应于套接字选项中的SO_SNDBUF<ul><li>用于操作发送缓冲区的大小</li><li>发送缓冲区用于保存发送数据，直到发送成功</li></ul></li><li>ChannelOption.SO_RCVBUF 对应于套接字选项中的SO_RCVBUF<ul><li>用于操作接收缓冲区的大小</li><li>接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功</li></ul></li><li>ChannelOption.SO_LINGER 对应于套接字选项中的SO_LINGER<ul><li>Linux 内核默认的处理方式是当用户调用close方法的时候，函数返回<ul><li>在可能的情况下，尽量发送数据，不一定保证会发生剩余的数据，造成了数据的不确定性</li></ul></li><li>使用SO_LINGER 可以阻塞close()的调用时间，直到数据完全发送</li></ul></li><li>ChannelOption.TCP_NODELAY 对应于套接字选项中的TCP_NODELAY<ul><li>该参数的使用与Nagle 算法有关，Nagle 算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次</li><li>因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送</li><li>虽然该方式有效提高网络的有效负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle 算法，使用于小数据即时传输</li></ul></li><li>ChannelOption.TCP_CORK 对应于套接字选项中的TCP_CORK<ul><li>该选项是需要等到发送的数据量最大的时候，一次性发送数据，适用于文件传输</li></ul></li></ul><h3 id="ByteBuf">ByteBuf</h3><ul><li>优点<ul><li>它可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer 的flip()方法</li><li>读和写使用了不同的索引<ul><li>名称以read 或者write 开头的ByteBuf 方法，将会推进其对应的索引</li><li>而名称以set 或者get 开头的操作则不会</li><li>如果打算读取字节直到readerIndex 达到和writerIndex会触发一个IndexOutOf-BoundsException</li><li>可以指定ByteBuf 的最大容量（默认的限制是Integer.MAX_VALUE）<ul><li>试图移动写索引（即writerIndex）超过这个值将会触发一个异常</li></ul></li></ul></li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持池化</li></ul></li><li>使用模式<ul><li>堆缓冲区：最常用的ByteBuf 模式是将数据存储在JVM 的堆空间中<ul><li>这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放</li><li>可以由hasArray()来判断检查ByteBuf 是否由数组支撑<ul><li>如果不是，则这是一个直接缓冲区</li></ul></li></ul></li><li>直接缓冲区<ul><li>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵</li></ul></li><li>复合缓冲区：它为多个ByteBuf 提供一个聚合视图<ul><li>比如HTTP 协议，分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的ByteBuf，将会在消息被发送的时候组装为一个ByteBuf，此时可以将这两个ByteBuf 聚合为一个CompositeByteBuf，然后使用统一和通用的ByteBuf API 来操作</li></ul></li></ul></li><li>分配<ul><li>ByteBufAllocator 接口<ul><li>buffer() 返回一个基于堆或者直接内存存储的ByteBuf</li><li>heapBuffer() 返回一个基于堆内存存储的ByteBuf</li><li>directBuffer() 返回一个基于直接内存存储的ByteBuf</li><li>compositeBuffer() 返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的CompositeByteBuf</li><li>ioBuffer() 返回一个用于套接字的I/O 操作的ByteBuf<ul><li>当所运行的环境具有sun.misc.Unsafe 支持时，返回基于直接内存存储的ByteBuf</li><li>否则返回基于堆内存存储的ByteBuf</li><li>当指定使用PreferHeapByteBufAllocator 时，则只会返回基于堆内存存储的ByteBuf</li></ul></li></ul></li><li>可以通过Channel（每个都可以有一个不同的ByteBufAllocator 实例）或者绑定到ChannelHandler 的ChannelHandlerContext 获取一个到ByteBufAllocator 的引用</li><li>Netty 提供了两种ByteBufAllocator 的实现<ul><li>PooledByteBufAllocator（默认）<ul><li>池化了ByteBuf 的实例以提高性能并最大限度地减少内存碎片</li></ul></li><li>Unpooled-ByteBufAllocator<ul><li>实现不池化ByteBuf 实例，并且在每次它被调用时都会返回一个新的实例</li></ul></li></ul></li></ul></li><li>Unpooled 缓冲区：Unpooled 工具类提供了静态的辅助方法来创建未池化的ByteBuf 实例<ul><li>buffer() 返回一个未池化的基于堆内存存储的ByteBuf</li><li>directBuffer()返回一个未池化的基于直接内存存储的ByteBuf</li><li>wrappedBuffer() 返回一个包装了给定数据的ByteBuf</li><li>copiedBuffer() 返回一个复制了给定数据的ByteBuf</li></ul></li><li>随机访问索引：使用那些需要一个索引值参数的方法来访问数据既不会改变readerIndex 也不会改变writerIndex<ul><li>可以通过调用readerIndex(index)或者writerIndex(index)来手动移动这两者</li></ul></li><li>顺序访问索引：<ul><li>get()和set()操作，从给定的索引开始，并且保持索引不变<ul><li>get+数据字长（bool.byte,int,short,long,bytes）</li></ul></li><li>read()和write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整</li></ul></li><li>读写操作<ul><li>isReadable() 如果至少有一个字节可供读取，则返回true</li><li>isWritable() 如果至少有一个字节可被写入，则返回true</li><li>readableBytes() 返回可被读取的字节数</li><li>writableBytes() 返回可被写入的字节数</li><li>capacity() 返回ByteBuf 可容纳的字节数<ul><li>在此之后，它会尝试再次扩展直到达到 maxCapacity()</li></ul></li><li>maxCapacity() 返回ByteBuf 可以容纳的最大字节数</li><li>hasArray() 如果ByteBuf 由一个字节数组支撑，则返回true</li><li>array() 如果ByteBuf 由一个字节数组支撑则返回该数组<ul><li>否则，它将抛出一个UnsupportedOperationException 异常</li></ul></li></ul></li><li>可丢弃字节<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-12.png" alt=""></li><li>可丢弃字节的分段包含了已经被读过的字节</li><li>通过调用discardReadBytes()方法，可以丢弃它们并回收空间</li><li>这个分段的初始大小为0，存储在readerIndex 中，会随着read 操作的执行而增加<ul><li><code>get*</code>操作不会移动readerIndex</li></ul></li><li>缓冲区上调用discardReadBytes()方法后，可丢弃字节分段中的空间已经变为可写的了</li><li>频繁地调用discardReadBytes()方法以确保可写分段的最大化<ul><li>这将极有可能会导致内存复制，因为可读字节必须被移动到缓冲区的开始位置</li><li>建议只在有真正需要的时候才这样做</li></ul></li></ul></li><li>可读字节<ul><li>ByteBuf 的可读字节分段存储了实际数据</li><li>新分配的、包装的或者复制的缓冲区的默认的readerIndex 值为0</li></ul></li><li>可写字节<ul><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6-13.png" alt=""></li><li>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域</li><li>新分配的缓冲区的writerIndex 的默认值为0</li><li>任何名称以write 开头的操作都将从当前的writerIndex 处开始写数据，并将它增加已经写入的字节数</li></ul></li><li>索引管理<ul><li>调用markReaderIndex()、markWriterIndex()、resetWriterIndex()和resetReaderIndex()来标记和重置ByteBuf 的readerIndex 和writerIndex</li><li>也可以通过调用readerIndex(int)或者writerIndex(int)来将索引移动到指定位置</li><li>试图将任何一个索引设置到一个无效的位置都将导致一个IndexOutOfBoundsException</li><li>可以通过调用clear()方法来将readerIndex 和writerIndex 都设置为0<ul><li>这并不会清除内存中的内容</li></ul></li></ul></li><li>查找操作：用来确定指定值的索引的方法<ul><li>indexOf()</li><li>forEachByte()<ul><li><code>ByteBuf buffer = .. .;</code></li><li><code>int index = buffer.forEachByte(ByteBufProcessor.FIND_CR);</code></li></ul></li></ul></li><li>派生缓冲区：其内部存储和 JDK 的ByteBuffer 一样也是共享的<ul><li>派生缓冲区为ByteBuf 提供了以专门的方式来呈现其内容的视图</li><li>创建方法<ul><li>duplicate()；slice()；slice(int, int)；Unpooled.unmodifiableBuffer(…)；order(ByteOrder)；readSlice(int)</li></ul></li><li>每个这些方法都将返回一个新的ByteBuf 实例，它具有自己的读索引、写索引和标记索引</li></ul></li><li>真实副本：不同于派生缓冲区，由这个调用所返回的ByteBuf 拥有独立的数据副本<ul><li>ByteBuf 复制如果需要一个现有缓冲区的真实副本，请使用copy()或者copy(int, int)方法</li></ul></li><li>引用计数：通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能</li><li>工具类：ByteBufUtil 提供了用于操作ByteBuf 的静态的辅助方法<ul><li>hexdump()方法，它以十六进制的表示形式打印ByteBuf 的内容</li><li><code>boolean equals(ByteBuf, ByteBuf)</code> 用来判断两个ByteBuf 实例的相等性</li></ul></li><li>资源释放<ul><li>当某个ChannelInboundHandler 的实现重写channelRead()方法时，它要负责显式地释放与池化的ByteBuf 实例相关的内存 <code>ReferenceCountUtil.release()</code></li><li>Netty 将使用WARN 级别的日志消息记录未释放的资源</li><li>更加简单的方式是使用SimpleChannelInboundHandler自动释放资源</li><li>对于入站请求，Netty 的EventLoop 在处理Channel 的读操作时进行分配ByteBuf（需要我们自行进行释放）<ul><li>使用SimpleChannelInboundHandler</li><li>在重写channelRead()方法使用ReferenceCountUtil.release()</li><li>在重写channelRead()方法使用使用ctx.fireChannelRead 继续向后传递</li></ul></li><li>对于出站请求，不管ByteBuf 是否由我们的业务创建的，当调用了write 或者writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;代码示例&lt;/li&gt;
&lt;li&gt;Bootstrap：引导&lt;/li&gt;
&lt;li&gt;EventLoop(Group)：控制流、多线程处理、并发&lt;/li&gt;
&lt;li&gt;Channel：Socket&lt;/li&gt;
&lt;li&gt;ChannelFuture：异步通知&lt;/li&gt;
&lt;li&gt;Chan</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Netty" scheme="https://jxch.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty-常用 ChannelHandler</title>
    <link href="https://jxch.github.io/2024/09/06/architect/netty/netty-chang-yong-channelhandler/"/>
    <id>https://jxch.github.io/2024/09/06/architect/netty/netty-chang-yong-channelhandler/</id>
    <published>2024-09-06T02:27:49.000Z</published>
    <updated>2024-09-06T02:29:06.372Z</updated>
    
    <content type="html"><![CDATA[<ul><li>粘包/半包</li><li>编解码器<ul><li>SSL/TLS</li><li>HTTP</li></ul></li><li>序列化</li><li>ChannelHandler 单元测试</li><li>channelRead 和 channelReadComplete<ul><li>读到完整的业务请求报文后才调用一次业务ChannelHandler 的 channelReadComplete 方法<ul><li>无论这条报文底层经过了几次SocketChannel 的read 调用</li></ul></li><li>channelRead 在每次从SocketChannel 成功读到消息后，由系统触发<ul><li>如果一个业务消息被TCP协议栈发送了N 次，则服务端的 channelRead 方法就会被调用 N 次</li></ul></li></ul></li></ul><hr><h2 id="粘包-半包">粘包/半包</h2><ul><li>主流协议的解决方案<ul><li>在包尾增加分割符，比如回车换行符进行分割，例如FTP 协议</li><li>消息定长，例如每个报文的大小为固定长度200 字节，如果不够，空位补空格</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段<ul><li>通常设计思路为消息头的第一个字段使用int32 来表示消息的总长度，使用LengthFieldBasedFrameDecoder</li></ul></li></ul></li></ul><hr><h2 id="编解码器">编解码器</h2><ul><li>解码器<ul><li>将字节解码为消息 <code>ByteToMessageDecoder&lt;I&gt;</code><ul><li>由于不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理</li><li>decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List<ul><li>对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该List，或者该ByteBuf 中没有更多可读取的字节时为止</li><li>如果该List 不为空，那么它的内容将会被传递给ChannelPipeline 中的下一个ChannelInboundHandler</li></ul></li></ul></li><li>将一种消息类型解码为另一种 <code>MessageToMessageDecoder&lt;T&gt;</code></li><li>TooLongFrameException：其将由解码器在帧超出指定的大小限制时抛出<ul><li>由于Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们</li><li>因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存</li></ul></li><li>可以设置一个最大字节数的阈值，如果超出该阈值，则会导致抛出一个TooLongFrameException<ul><li>如何处理该异常则完全取决于该解码器的用户<ul><li>可能返回一个特殊的响应；可能就是关闭对应的连接</li></ul></li><li>位于ChannelPipeline 中的其他ChannelHandler 可以选择在exceptionCaught()方法中处理该异常或者忽略它</li></ul></li></ul></li><li>编码器<ul><li>将消息编码为字节 <code>MessageToByteEncoder&lt;I&gt;</code></li><li>将消息编码为消息 <code>MessageToMessageEncoder&lt;T&gt;</code></li></ul></li><li>编解码器：同时实现了ChannelInboundHandler 和 ChannelOutboundHandler<ul><li>ByteToMessageCodec MessageToMessageCodec</li></ul></li></ul><h3 id="SSL-TLS">SSL/TLS</h3><ul><li>SSLContext 和 SSLEngine 类实现解密和加密</li><li>Netty 通过一个名为SslHandler 的ChannelHandler 实现利用了这个 API<ul><li>其中SslHandler 在内部使用SSLEngine 来完成实际的工作</li></ul></li><li>在大多数情况下，SslHandler 将是ChannelPipeline 中的第一个ChannelHandler</li></ul><h3 id="HTTP">HTTP</h3><ul><li>所有类型的 HTTP 消息都实现了HttpObject 接口</li><li>HttpRequestEncoder 将HttpRequest、HttpContent 和LastHttpContent 消息编码为字节</li><li>HttpResponseEncoder 将HttpResponse、HttpContent 和LastHttpContent 消息编码为字节</li><li>HttpRequestDecoder 将字节解码为HttpRequest、HttpContent 和LastHttpContent 消息</li><li>HttpResponseDecoder 将字节解码为HttpResponse、HttpContent 和LastHttpContent 消息</li><li>HttpClientCodec 和HttpServerCodec 则将请求和响应做了一个组合</li><li>聚合 HTTP 消息 HttpObjectAggregator：可以将多个消息部分合并为FullHttpRequest 或者FullHttpResponse 消息</li><li>HTTP 压缩：Netty 为压缩和解压缩提供了ChannelHandler 实现，它们同时支持gzip 和deflate 编码</li><li>HTTPS：启用HTTPS 只需要将SslHandler 添加到ChannelPipeline 的ChannelHandler 组合中</li></ul><hr><h2 id="序列化">序列化</h2><ul><li>Java 序列化的缺点<ul><li>无法跨语言</li><li>序列化后的码流太大</li><li>序列化性能太低</li></ul></li><li>Netty 内置了对 JBoss Marshalling 和 Protocol Buffers 的支持</li><li>protobuf<ul><li>发送<ul><li>添加消息长度 ProtobufVarint32LengthFieldPrepender</li><li>序列化 ProtobufEncoder</li></ul></li><li>接收<ul><li>去除消息长度 ProtobufVarint32FrameDecoder</li><li>反序列化 ProtobufDecoder</li></ul></li></ul></li><li>集成第三方的序列化框架 MessagePack<ul><li>需要自定义消息头 LengthFieldBasedFrame</li><li>然后在发送端添加消息头，接收端去除消息头</li></ul></li><li>LengthFieldBasedFrame<ul><li>maxFrameLength：表示的是包的最大长度</li><li>lengthFieldOffset：指的是长度域的偏移量，表示跳过指定个数字节之后的才是长度域</li><li>lengthFieldLength：记录该帧数据长度的字段，也就是长度域本身的长度</li><li>lengthAdjustment：长度的一个修正值，可正可负<ul><li>Netty 在读取到数据包的长度值N 后，认为接下来的N 个字节都是需要读取的</li><li>但是根据实际情况，有可能需要增加N 的值，也有可能需要减少N 的值</li><li>具体增加多少，减少多少，写在这个参数里</li></ul></li><li>initialBytesToStrip：从数据帧中跳过的字节数<ul><li>表示得到一个完整的数据包之后，扔掉这个数据包中多少字节数，才是后续业务实际需要的业务数据</li></ul></li><li>failFast：建议不要修改，否则可能会造成内存溢出<ul><li>如果为true（默认），则表示读取到长度域<ul><li>TA 的值的超过maxFrameLength，就抛出一个TooLongFrameException</li></ul></li><li>为false 表示只有当真正读取完长度域的值表示的字节之后，才会抛出TooLongFrameException</li></ul></li></ul></li></ul><hr><h2 id="ChannelHandler-单元测试">ChannelHandler 单元测试</h2><ul><li>EmbeddedChannel<ul><li>将入站数据或者出站数据写入到EmbeddedChannel 中，然后检查是否有任何东西到达了ChannelPipeline 的尾端<ul><li>以这种方式，你便可以确定消息是否已经被编码或者被解码过了，以及是否触发了任何的ChannelHandler 动作</li></ul></li><li><img src="/static/IT/Netty/Netty-%E5%B8%B8%E7%94%A8-ChannelHandler-1.png" alt="EmbeddedChannel"></li><li>writeInbound 将入站消息写到EmbeddedChannel 中<ul><li>如果可以通过readInbound()方法从EmbeddedChannel 中读取数据，则返回true</li></ul></li><li>readInbound 从EmbeddedChannel 中读取一个入站消息<ul><li>任何返回的东西都穿越了整个ChannelPipeline。如果没有任何可供读取的，则返回null</li></ul></li><li>writeOutbound 将出站消息写到EmbeddedChannel 中<ul><li>如果现在可以通过readOutbound()方法从EmbeddedChannel 中读取到什么东西，则返回true</li></ul></li><li>readOutbound 从EmbeddedChannel 中读取一个出站消息<ul><li>任何返回的东西都穿越了整个ChannelPipeline。如果没有任何可供读取的，则返回null</li></ul></li><li>finish 将EmbeddedChannel 标记为完成<ul><li>并且如果有可被读取的入站数据或者出站数据，则返回true</li><li>这个方法还将会调用EmbeddedChannel 上的close()方法</li></ul></li><li>使用writeOutbound()方法将消息写到Channel 中，并通过ChannelPipeline 沿着出站的方向传递。随后，你可以使用readOutbound()方法来读取已被处理过的消息，以确定结果是否和预期一样。类似地，对于入站数据，你需要使用writeInbound()和readInbound()方法</li><li>在每种情况下，消息都将会传递过ChannelPipeline，并且被相关的 ChannelInboundHandler 或者ChannelOutboundHandler 处理</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;粘包/半包&lt;/li&gt;
&lt;li&gt;编解码器
&lt;ul&gt;
&lt;li&gt;SSL/TLS&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;li&gt;ChannelHandler 单元测试&lt;/li&gt;
&lt;li&gt;channelRead 和 cha</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Netty" scheme="https://jxch.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB-SpringBoot集成</title>
    <link href="https://jxch.github.io/2024/09/06/architect/mongodb/mongodb-springboot-ji-cheng/"/>
    <id>https://jxch.github.io/2024/09/06/architect/mongodb/mongodb-springboot-ji-cheng/</id>
    <published>2024-09-06T02:16:49.000Z</published>
    <updated>2024-09-06T02:16:49.940Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MongoTemplate<ul><li>CRUD<ul><li>实体 <code>@Document @Id @Field @Transient</code><ul><li><code>@Transient</code> 指定此成员变量不参与文档的序列化</li></ul></li><li><code>Query</code><ul><li><code>Criteria</code></li><li><code>Sort</code></li><li><code>new BasicQuery(json)</code></li></ul></li></ul></li><li>聚合操作 <code>MongoTemplate#aggregate</code><ul><li><code>Aggregation</code></li><li><code>TypedAggregation</code><ul><li><code>GroupOperation</code></li><li><code>MatchOperation</code></li><li><code>SortOperation</code></li><li><code>ProjectionOperation</code></li></ul></li></ul></li><li>事务操作<ul><li>编程式事务：<code>TransactionOptions -&gt; ClientSession</code></li><li>声明式事务（配置事务管理器）：<code>MongoDatabaseFactory -&gt; MongoTransactionManager</code></li></ul></li><li>change stream：<code>MessageListenerContainer</code></li></ul></li></ul><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 编程式事务</span><span class="token keyword">var</span> txo <span class="token operator">=</span> <span class="token class-name">TransactionOptions</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readPreference</span><span class="token punctuation">(</span><span class="token class-name">ReadPreference</span><span class="token punctuation">.</span><span class="token function">primary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readConcern</span><span class="token punctuation">(</span><span class="token class-name">ReadConcern</span><span class="token punctuation">.</span><span class="token constant">MAJORITY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeConcern</span><span class="token punctuation">(</span><span class="token class-name">WriteConcern</span><span class="token punctuation">.</span><span class="token constant">MAJORITY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ClientSession</span> clientSession <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">startSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>clientSession<span class="token punctuation">.</span><span class="token function">startTransaction</span><span class="token punctuation">(</span>txo<span class="token punctuation">)</span><span class="token punctuation">;</span>clientSession<span class="token punctuation">.</span><span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>clientSession<span class="token punctuation">.</span><span class="token function">abortTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回滚事务</span><span class="token punctuation">}</span><span class="token comment">// 声明式事务：配置事务管理器 -&gt; @Transactional</span><span class="token annotation punctuation">@Bean</span><span class="token class-name">MongoTransactionManager</span> <span class="token function">transactionManager</span><span class="token punctuation">(</span><span class="token class-name">MongoDatabaseFactory</span> factory<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">TransactionOptions</span> txnOptions <span class="token operator">=</span> <span class="token class-name">TransactionOptions</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readPreference</span><span class="token punctuation">(</span><span class="token class-name">ReadPreference</span><span class="token punctuation">.</span><span class="token function">primary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readConcern</span><span class="token punctuation">(</span><span class="token class-name">ReadConcern</span><span class="token punctuation">.</span><span class="token constant">MAJORITY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeConcern</span><span class="token punctuation">(</span><span class="token class-name">WriteConcern</span><span class="token punctuation">.</span><span class="token constant">MAJORITY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MongoTransactionManager</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// change stream</span><span class="token comment">// 配置 mongo 监听器的容器 MessageListenerContainer</span><span class="token comment">// spring 启动时会自动启动监听的任务用于接收 changestream</span><span class="token annotation punctuation">@Bean</span><span class="token class-name">MessageListenerContainer</span> <span class="token function">messageListenerContainer</span><span class="token punctuation">(</span><span class="token class-name">MongoTemplate</span> template<span class="token punctuation">,</span> <span class="token class-name">DocumentMessageListener</span> documentMessageListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">MessageListenerContainer</span> messageListenerContainer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMessageListenerContainer</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAutoStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token class-name">ChangeStreamRequest</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Document</span><span class="token punctuation">&gt;</span></span> request <span class="token operator">=</span> <span class="token class-name">ChangeStreamRequest</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>documentMessageListener<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collection</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span> <span class="token comment">//需要监听的集合名 </span><span class="token comment">//过滤需要监听的操作类型，可以根据需求指定过滤条件 </span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Aggregation</span><span class="token punctuation">.</span><span class="token function">newAggregation</span><span class="token punctuation">(</span>  <span class="token class-name">Aggregation</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span> <span class="token class-name">Criteria</span>  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">"operationType"</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">in</span><span class="token punctuation">(</span><span class="token string">"insert"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//不设置时，文档更新时，只会发送变更字段的信息，设置UPDATE_LOOKUP会返回文档的全部信息 </span><span class="token punctuation">.</span><span class="token function">fullDocumentLookup</span><span class="token punctuation">(</span><span class="token class-name">FullDocument</span><span class="token punctuation">.</span><span class="token constant">UPDATE_LOOKUP</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   messageListenerContainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">Document</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> messageListenerContainer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 配置mongo监听器，用于接收数据库的变更信息</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DocumentMessageListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">MessageListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>  <span class="token string">"Received Message in collection %s.\n\trawsource: %s\n\tconverted: %s"</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCollectionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getRaw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;MongoTemplate
&lt;ul&gt;
&lt;li&gt;CRUD
&lt;ul&gt;
&lt;li&gt;实体 &lt;code&gt;@Document @Id @Field @Transient&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Transient&lt;/code&gt; 指定此成员变量不参与文档的</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MongoDB" scheme="https://jxch.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB-Change Stream</title>
    <link href="https://jxch.github.io/2024/09/06/architect/mongodb/mongodb-change-stream/"/>
    <id>https://jxch.github.io/2024/09/06/architect/mongodb/mongodb-change-stream/</id>
    <published>2024-09-06T02:11:49.000Z</published>
    <updated>2024-09-06T02:13:27.026Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Change Stream 指数据的变化事件流，MongoDB从3.6版本开始提供订阅数据变更的功能<ul><li>是用于实现变更追踪的解决方案</li><li><img src="/static/IT/MongoDB/MongoDB-Change-Stream-1.png" alt="Change Stream"></li></ul></li><li>Change Stream 的实现原理：是基于 oplog 实现的，提供推送实时增量的推送功能<ul><li>它在 oplog 上开启一个 tailable cursor 来追踪所有复制集上的变更操作，最终调用应用中定义的回调函数</li><li>被追踪的变更事件主要包括<ul><li>insert/update/delete：插入、更新、删除；</li><li>drop：集合被删除；</li><li>rename：集合被重命名；</li><li>dropDatabase：数据库被删除；</li><li>invalidate：drop/rename/dropDatabase 将导致 invalidate 被触发， 并关闭 change stream；</li></ul></li></ul></li><li>如果只对某些类型的变更事件感兴趣，可以使用使用聚合管道的过滤步骤过滤事件<ul><li><code>var cs = db.user.watch([{ $match:{operationType:{$in:["insert","delete"]}} }])</code></li></ul></li><li>Change Stream会采用 <code>readConcern:majority</code> 这样的一致性级别，保证写入的变更不会被回滚<ul><li>未开启 majority readConcern 的集群无法使用 Change Stream；</li><li>当集群无法满足 <code>{w:majority}</code> 时，不会触发 Change Stream（例如 PSA 架构 中的 S 因故障宕机）</li></ul></li><li>Change Stream 故障恢复<ul><li><img src="/static/IT/MongoDB/MongoDB-Change-Stream-2.png" alt="Change Stream 故障恢复"></li><li>假设在一系列写入操作的过程中，订阅 Change Stream 的应用在接收到“写3”之后 于 t0 时刻崩溃<ul><li>想要从上次中断的地方继续获取变更流，只需要保留上次变更通知中的 <code>_id</code> 即可</li><li>Change Stream 回调所返回的的数据带有 <code>_id</code>，这个 <code>_id</code> 可以用于断点恢复</li><li><code>var cs = db.collection.watch([], {resumeAfter: &lt;_id&gt;})</code></li></ul></li></ul></li><li>使用场景<ul><li>跨集群的变更复制——在源集群中订阅 Change Stream，一旦得到任何变更立即写入目标集群</li><li>微服务联动——当一个微服务变更数据库时，其他微服务得到通知并做出相应的变更</li><li>其他任何需要系统联动的场景<ul><li>监控；消息推送</li><li>分析平台：推到下游的计算平台</li><li>数据同步：热备份；冷备份</li></ul></li></ul></li><li>注意事项<ul><li>Change Stream 依赖于 oplog，因此中断时间不可超过 oplog 回收的最大时间窗</li><li>在执行 update 操作时，如果只更新了部分数据，那么 Change Stream 通知的也是增量部分</li><li>删除数据时通知的仅是删除数据的 <code>_id</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Change Stream 指数据的变化事件流，MongoDB从3.6版本开始提供订阅数据变更的功能
&lt;ul&gt;
&lt;li&gt;是用于实现变更追踪的解决方案&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;/static/IT/MongoDB/MongoDB-Change-Str</summary>
      
    
    
    
    <category term="IT学习笔记" scheme="https://jxch.github.io/categories/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MongoDB" scheme="https://jxch.github.io/tags/MongoDB/"/>
    
  </entry>
  
</feed>
